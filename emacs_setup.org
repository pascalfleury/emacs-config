#+TITLE: Paf's portable Emacs configuration
#+AUTHOR: Pascal Fleury
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

This is my Emacs config. You need to tangle this into a file that then gets loaded by Emacs: =C-c C-v t= [org-babel-tangle]. Below, I also explain how this tangling is automated.

Find extensive documentation about how to do this [[https://github.com/larstvei/dot-emacs][here]].

* Personal Plans
I regularly try out new packages, this is my current list of things being evaluated.
They usually live temporarily in my =~/.emacs= until I am happy, in which case I move their config into this file so that it gets replicated on all machines I work on with Emacs.

** Currently under review
  - [[https://github.com/yjwen/org-reveal][ox-reveal]] (see [[https://github.com/yjwen/org-reveal#set-the-location-of-revealjs][installation]])

** Make the config work fine when initially installed
*** DONE F12 does not find any files
CLOSED: [2021-06-04 Fri 22:36]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-06-04 Fri 22:36]
- State "TODO"       from              [2021-02-03 Wed 16:52]
:END:
because nothing is set in the =org-agenda-files=
*** DONE maybe complain when org-directory is not set to an existing directory
CLOSED: [2021-08-19 Thu 16:45]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-08-19 Thu 16:45]
- State "TODO"       from              [2021-02-03 Wed 16:53]
:END:
*** TODO Avoid showing the welcome screen if a file was requested on cmdline
:LOGBOOK:
- State "TODO"       from              [2021-06-04 Fri 23:41]
:END:
*** TODO Tangle the config file into =~/.emacs.d/personal.el= and have =~/.emacs.d/init.el= load that.
:LOGBOOK:
- State "TODO"       from              [2021-08-19 Thu 16:46]
:END:

* One-time Initial Setup
I have my config in directory =~/Emacs= which is where I clone this repository. The config setup is maintained purely in the =~/Emacs/emacs_setup.org= file.

In your =~/.emacs= file, all you need to add is

#+NAME: emacs_bootstrap
#+BEGIN_SRC emacs-lisp :tangle dot_emacs.el

;; Setup your Org directory
(setq org-directory "~/OrgFiles")

;; Loads PAF's emacs setup with bootstrap
(load-file "~/Emacs/emacs_setup.el")
#+end_src

** Bootstrap
Initially when cloning this repository, you have the =emacs_setup.org= file, that contains the config that you adapt to your specific setup, and an =emacs_setup.el= with a bootstrap content that will tangle and compile the org file, /and replace itself/. This is useful the very first time.

After that, the config itself should have the hook to re-tangle and re-compile the setup at each save.

Therefore my setup is very easy to install, and it needs these steps:

1. clone this repo into =~/Emacs=
2. add the one line in you =~/.emacs=
3. make sure Emacs re-interprets its init (you could restart it)

It may be that [[https://github.com/jwiegley/use-package][use-package]] is not installed on your setup, so it will first try to install that. After that step, it will also start installing any package that is marked as needed in this config automatically.

The original content of the =emacs_setup.el= is as follows:

#+begin_src emacs-lisp :tangle (expand-file-name "emacs_setup.el" temporary-file-directory)
;; This is the initial state of the file to be loaded.
;; It will replace itself with the actual configuration at first run.

(require 'org) ; We can't tangle without org!

(setq config_base (expand-file-name "emacs_setup"
				    (file-name-directory
				     (or load-file-name buffer-file-name))))
(find-file (concat config_base ".org"))        ; Open the configuration
(org-babel-tangle)                             ; tangle it
(load-file (concat config_base ".el"))         ; load it
(byte-compile-file (concat config_base ".el")) ; finally byte-compile it
#+end_src

** Recompile all packages
This will force-recompile everything in =~/.emacs.d/elpa/...= Just run =M-:= and then enter this:
#+begin_src emacs-lisp :tangle no
(byte-recompile-directory package-user-dir nil 'force)
#+end_src
or simply =C-x C-e= at the end of that line.

** One-time configure
To preserve the original state of this file when updating the git repos with new config settings, execute the following block once (=C-c C-c=):

*** TODO detect the system better
:LOGBOOK:
- State "TODO"       from              [2021-02-03 Wed 16:57]
:END:
currently it does not a good job of figuring out the diff between OSX, Linux, Termux (android) and Windows.

#+begin_src bash :noweb yes :tangle onetime_setup.sh
  #!/bin/bash
  # Make git ignore the tangled & updated emacs_setup.el
  if [[ -z "$(which git)" ]]; then
    echo "You will need 'git' to be installed !"
    exit 1
  fi
  if  [[ -z "$(which emacs)" ]]; then
    echo "You might need 'emacs' for this to be useful !"
    exit 1
  fi

  GIT_ROOT=$(dirname $0)
  (cd ${GIT_ROOT} && git update-index --skip-worktree emacs_setup.el)

  # Maybe this is a new install, .emacs does not exist
  test -e ~/.emacs || touch ~/.emacs

  # Initial tangle of files, saying no to vterm compilation
  emacs --batch --load ${GIT_ROOT}/emacs_setup.el

  # Add the load-file as the first thing in the user's ~/.emacs
  # If not yet added.
  declare lines=$(grep ';; dot_emacs.el' ~/.emacs | wc -l)
  if (( lines < 1 )); then
    echo "Added loading the config in your ~/.emacs"
    echo ";; dot_emacs.el" > ~/.emacs.new
    cat ${GIT_ROOT}/dot_emacs.el >> ~/.emacs.new
    cat ~/.emacs >> ~/.emacs.new
    mv ~/.emacs.new ~/.emacs
  else
    echo "Config in your ~/.emacs already set up!"
  fi

  # Install system dependencies
  echo "Installing dependencies"
  bash ${GIT_ROOT}/install_deps.sh

  echo "Cleanup"
  rm ${GIT_ROOT}/dot_emacs.el
  rm ${GIT_ROOT}/install_deps.sh
#+end_src

This script is then used to install the needed packages on the system.
#+begin_src bash :noweb yes :tangle install_deps.sh
  #!/bin/bash
  set -e

  # Trick to make it work on Termux
  #which "ls" || pkg install debianutils

  # This is a bit of heuristics to find out what the install system is
  # They are attempted in this order, put the least likely first.
  declare -a PKG_MGRS=("pkg" "brew" "apt-get")

  PKG_PREFIX_apt_get="sudo"
  PKG_POSTFIX_apt_get="-y"

  for pkg in "${PKG_MGRS[@]}"; do
      if [[ -x "$(which ${pkg})" ]]; then
          INSTALLER="${pkg}"
          break
      fi
  done
  if [[ -z "${INSTALLER}" ]]; then
      echo "Did not find a suitable installer (tried ${PKG_MGRS[@]})"
      exit 1
  fi

  # This is the function to call to install anything. It can optionally
  # check for a binary and avoid installing if it's found.  install_pkg
  # [-x <binary>] <package>
  function install_pkg() {
      if [[ "$1" == "-x" ]]; then
          local binary="$(which $2)"
          if [[ -n "${binary}" && -x "${binary}" ]]; then
              echo "Found $2 (${binary}), nothing to install for $3."
              return
          fi
          shift 2
      fi

      local token=$(echo -n ${INSTALLER} | tr -c '0-9a-zA-Z_' '_')
      local prefix_var="PKG_PREFIX_${token}"
      local postfix_var="PKG_POSTFIX_${token}"

      echo "Trying: ${INSTALLER} install $*"
      ${!prefix_var} $(which ${INSTALLER}) ${!postfix_var} install "$@"
  }
#+end_src

* Initialize Emacs
This section sets up Emacs so it can tangle the config, find =use-package=, and find the ELPA repositories where to get the new packes from.
** Info header
Just to add a little information in the tangled file.
#+begin_src emacs-lisp
  ;; ===== this file was auto-tangled, only edit the emacs_setup.org =====
  ;; (profiler-start 'cpu)
#+end_src

** This config directory
A variable so we can refer to this all over the place.

Maybe there is a way to auto-detect this and generate it with literate programming or such.
#+begin_src emacs-lisp
  (setq emacs-config-directory "~/Emacs")
  (setq paf-lisp-directory (expand-file-name "lisp" emacs-config-directory))
  (setq paf-emacs-init (expand-file-name "emacs_setup.el" emacs-config-directory))
#+end_src

** MELPA
Make sure we have the package system initialized before we load anything.
#+begin_src emacs-lisp
(require 'package)
(when (< emacs-major-version 27)
  (package-initialize))
#+end_src

Adding my choice of packages repositories.
#+NAME melpa-setup
#+begin_src emacs-lisp
    (setq package-archives '(
                             ;;("org" . "https://orgmode.org/elpa/")
                             ("melpa" . "https://melpa.org/packages/")
                             ("stable-melpa" . "https://stable.melpa.org/packages/")
                             ("nongnu" . "https://elpa.nongnu.org/nongnu/")
                             ("gnu" . "https://elpa.gnu.org/packages/")
                            ))
#+end_src

Note that 'melpa' is needed for these:
 - hc-zenburn-theme
 - column-enforce-mode
 - popup-kill-ring
 - tj3-mode
 - google-c-style
 - git-gutter-fringe+
 - bazel
 - org-clock-convenience
 - ox-reveal

** use-package
I use =use-package= for most configuration, and that needs to be at the top of the file.  =use-package= verifies the presence of the requested package, otherwise installs it, and presents convenient sections for configs of variables, key bindings etc. that happen only if the package is actually loaded.

First, make sure it gets installed if it is not there yet.
#+begin_src emacs-lisp
  ;; make sure use-package is installed
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
#+end_src

#+begin_src emacs-lisp
(eval-when-compile (require 'use-package))
#+end_src
** tangle-this-config
I set this up to tangle the init org-mode file into the actual Emacs init file as soon as I save it.
#+begin_src emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are
    tangled, and the tangled file is compiled."
    (when (equal (buffer-file-name)
                 (expand-file-name "emacs_setup.org" emacs-config-directory))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
        (org-babel-tangle)
        ;; (byte-compile-file paf-emacs-init)
        )))

  (add-hook 'after-save-hook 'tangle-init)
#+end_src
** Speedup startup time
*** Temporarily disable GC
#+begin_src emacs-lisp
  ;; Minimize garbage collection during startup
  (setq gc-cons-threshold most-positive-fixnum)

  ;; Lower threshold back to 8 MiB (default is 800kB)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (expt 2 23))))
#+end_src

*** Add the startup profiler
#+begin_src emacs-lisp :tangle no
  (use-package esup
    :ensure t
    :pin stable-melpa)
#+end_src

** Detect System
Some hints about how to do this are [[http://ergoemacs.org/emacs/elisp_determine_OS_version.html][here]].

#+begin_src emacs-lisp
;; Detect the current system and capabilities
#+end_src

* Personal Initialization
** Clear =C-p= so I can use it as a prefix
Remove =C-p= that I want to use for *me* personally as a prefix.
#+begin_src emacs-lisp
(global-set-key (kbd "C-p") nil) ;; was 'previous-line'
#+end_src

** Initial scratch content
#+begin_src emacs-lisp
(setq initial-scratch-message "; Paf's unsaved ramblings and tests...\n")
#+end_src

** Splash screen
#+begin_src emacs-lisp
  (defun get-resource (name)
    (let* ((resource-dir (expand-file-name "Resources" emacs-config-directory)))
      (expand-file-name name resource-dir)))
  (if window-system
      (progn
	(setq initial-buffer-choice (get-resource "welcome.org"))
	(setq fancy-splash-image (get-resource "paf_emacs.svg"))
	(setq org-startup-with-inline-images t))
    (setq initial-buffer-choice (get-resource "welcome_nox.org")))
#+end_src

* Helper Functions
** add-hook-run-once
Use instead of add-hook to run it a single time.
[[https://emacs.stackexchange.com/questions/3323/is-there-any-way-to-run-a-hook-function-only-once][found here]]
#+begin_src emacs-lisp
(defmacro add-hook-run-once (hook function &optional append local)
  "Like add-hook, but remove the hook after it is called"
  (let ((sym (make-symbol "#once")))
    `(progn
       (defun ,sym ()
         (remove-hook ,hook ',sym ,local)
         (funcall ,function))
       (add-hook ,hook ',sym ,append ,local))))
#+end_src

** truncate a string
#+begin_src emacs-lisp
  (defun paf/truncate-string (text &optional len ellipsis)
    "Truncate the text to a given length.

  When LEN is a number, resulting string is truncated at that length.
  If the length is bigger, then '...' is added at the end.

  Usage example:

    (setq org-agenda-prefix-format
          '((agenda . \" %(paf/truncate-string (roam-extras/extract-agenda-category) 12) %?-12t %12s\")))

  Refer to `org-agenda-prefix-format' for more information."
    (interactive)
    (if (and (numberp len) (> (length text) len))
        (let* ((used-ellipsis (if (eq ellipsis nil) "…" ellipsis))
               (ellipsis-length (length used-ellipsis))
               (short-text (substring text 0 (- len ellipsis-length))))
          (format "%s%s" short-text used-ellipsis))
      text))

  ;; (setq paf-tests/truncate (paf/truncate-string "Here is some long text" 10))
#+end_src

* Environment
** Browser default
#+begin_src emacs-lisp
(setq browse-url-generic-program (executable-find "google-chrome")
  browse-url-browser-function 'browse-url-generic)
#+end_src

** Setup server
Start the background server, so we can use emacsclient.
#+begin_src emacs-lisp
  (if (and (fboundp 'server-running-p)
           (not (server-running-p)))
      (server-start))
#+end_src

** UTF-8
 Make Emacs request UTF-8 first when pasting stuff.
#+begin_src emacs-lisp
(use-package unicode-escape
  :ensure t
  :init
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
(set-language-environment "UTF-8")
#+end_src

** Newline (only Unix wanted)
This should automatically convert any files with dos or Mac line endings into Unix style ones. Code found [[https://www.emacswiki.org/emacs/EndOfLineTips][here]].
#+begin_src emacs-lisp
  (defun no-junk-please-we-are-unixish ()
    (let ((coding-str (symbol-name buffer-file-coding-system)))
      (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
        (set-buffer-file-coding-system 'unix))))

  (add-hook 'find-file-hook 'no-junk-please-we-are-unixish)
#+end_src

** auto revert
Use =auto-revert=, which reloads a file if it's updated on disk
and not modified in the buffer.
#+begin_src emacs-lisp
  (global-auto-revert-mode 1)
#+end_src

** enable upcase- and downcase-region and narrowing
these got disabled in Emacs 19 (!) because they were considered confusing.
Re-enabling them here.
Use =C-x C-u= and =C-x C-l= to effect them.

#+begin_src emacs-lisp
  (put 'upcase-region 'disabled nil)  ;; C-x C-u
  (put 'downcase-region 'disabled nil)  ;; C-x C-l (lowercase L)

  ;; C-x n <key>. Widen with C-x n w
  (put 'narrow-to-region 'disabled nil)  ; C-x n n
  (put 'narrow-to-defun  'disabled nil)
  (put 'narrow-to-page   'disabled nil)
#+end_src

** Calendar starts on Monday
#+begin_src emacs-lisp
  ;; Calendar starts on Monday
  (setq calendar-week-start-day 1)
#+end_src

* Managing Buffers
** winner-mode
Enables =winner-mode=. Navigate buffer-window configs with =C-c left= and =C-c right=.
#+begin_src emacs-lisp
(winner-mode 1)
#+end_src

** popper.el: deal with popup windows
A minor-mode to deal with lots of popup windows and bring some order in them.
See [[https://github.com/karthink/popper][github:popper]] for more information.
#+begin_src emacs-lisp
  (use-package popper
    :ensure t
    :after projectile
    :bind (("<C-tab>"   . popper-toggle-latest)
           ("<C-S-tab>" . popper-cycle)
           ("<C-M-tab>" . popper-toggle-type))
    :init
    (setq popper-reference-buffers
          '("\\*Messages\\*"
            "\\*Bufler\\*"
            "Output\\*$"
            help-mode
            compilation-mode))
    (setq popper-group-function #'popper-group-by-projectile)
    (popper-mode +1))
#+end_src

** [[https://github.com/nex3/perspective-el][perspective]]
#+begin_src emacs-lisp
  (use-package perspective
    :ensure t
    :bind
    (("C-x C-b" . persp-list-buffers)
     ("C-x b" . persp-switch-to-buffer*)
     ("C-x k" . persp-kill-buffer*)
     )
    :hook (kill-emacs-hook . persp-state-save)
    :config
    (persp-mode)
    (setq persp-state-default-file
          (expand-file-name "perspective.save" user-emacs-directory)))
#+end_src

** toggle-maximize-buffer
Temporarily maximize a buffer.
[[https://gist.github.com/mads379/3402786][found here]]
#+begin_src emacs-lisp
  (defun toggle-maximize-buffer () "Maximize buffer"
         (interactive)
         (if (= 1 (length (window-list)))
             (jump-to-register '_)
           (progn
             (window-configuration-to-register '_)
             (delete-other-windows))))
  ;;Map it to a key.
  (global-set-key (kbd "M-<f8>") 'toggle-maximize-buffer)
#+end_src

* Colors and Look
** In terminal mode
#+begin_src emacs-lisp
(when (display-graphic-p)
  (set-background-color "#ffffff")
  (set-foreground-color "#141312"))
#+end_src

** In X11 mode: mouse and window title
#+begin_src emacs-lisp
(setq frame-title-format "emacs @ %b - %f")
(when window-system
  (mouse-wheel-mode)  ;; enable wheelmouse support by default
  (set-selection-coding-system 'compound-text-with-extensions))
#+end_src

** Look: buffer naming
#+begin_src emacs-lisp
(use-package uniquify
  :init
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+end_src

** Buffer Decorations
Setup the visual cues about the current editing buffer
#+begin_src emacs-lisp
(column-number-mode t)
(setq visible-bell t)
(setq scroll-step 1)
(setq-default transient-mark-mode t)  ;; highlight selection
#+end_src

** nyan-mode
#+begin_src emacs-lisp
(use-package nyan-mode
  :ensure t
  :bind ("C-p n" . 'nyan-mode))
#+end_src

** dynamic cursor colors
The cursor is displayed in different colors, depending on overwrite or insert mode.
#+begin_src emacs-lisp
(setq hcz-set-cursor-color-color "")
(setq hcz-set-cursor-color-buffer "")

(defun hcz-set-cursor-color-according-to-mode ()
  "change cursor color according to some minor modes."
  ;; set-cursor-color is somewhat costly, so we only call it when needed:
  (let ((color
         (if buffer-read-only "orange"
           (if overwrite-mode "red"
             "green"))))
    (unless (and
             (string= color hcz-set-cursor-color-color)
             (string= (buffer-name) hcz-set-cursor-color-buffer))
      (set-cursor-color (setq hcz-set-cursor-color-color color))
      (setq hcz-set-cursor-color-buffer (buffer-name)))))

(add-hook 'post-command-hook 'hcz-set-cursor-color-according-to-mode)
#+end_src

** theme / faces
I really like the high-contract Zenburn theme.
#+begin_src emacs-lisp
  (use-package hc-zenburn-theme
    :ensure t)

  ;; This makes some of the faces a bit more contrasted.
  ;; faces for general region highlighting zenburn is too low-key.
  (custom-set-faces
   '(highlight ((t (:background "forest green"))))
   '(region ((t (:background "forest green")))))
#+end_src

* Key Mappings
** which-key
This will show the list of the possible completion keys during a longer key sequence.
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :custom (which-key-idle-delay 2.0)
    :config (which-key-mode t))
#+end_src

** alternate key mappings
Letting one enter chars that are otherwise difficult in e.g. the minibuffer.
#+begin_src emacs-lisp
(global-set-key (kbd "C-m") 'newline-and-indent)
(global-set-key (kbd "C-j") 'newline)
(global-set-key [delete] 'delete-char)
(global-set-key [kp-delete] 'delete-char)
#+end_src

** home and end
#+begin_src emacs-lisp
  (global-set-key (kbd "<home>") 'beginning-of-line)
  (global-set-key (kbd "<end>") 'end-of-line)
#+end_src

** Macros
#+begin_src emacs-lisp
(global-set-key [f3] 'start-kbd-macro)
(global-set-key [f4] 'end-kbd-macro)
(global-set-key [f5] 'call-last-kbd-macro)
#+end_src

** Text size
Increase/decrease text size
#+begin_src emacs-lisp
(define-key global-map (kbd "C-+") 'text-scale-increase)
(define-key global-map (kbd "C--") 'text-scale-decrease)
#+end_src

** multiple regions
#+begin_src emacs-lisp
(global-set-key (kbd "C-M-i") 'iedit-mode)
#+end_src

** Moving around buffers
#+begin_src emacs-lisp
(global-set-key (kbd "C-c <C-left>")  'windmove-left)
(global-set-key (kbd "C-c <C-right>") 'windmove-right)
(global-set-key (kbd "C-c <C-up>")    'windmove-up)
(global-set-key (kbd "C-c <C-down>")  'windmove-down)
(global-set-key (kbd "C-c C-g") 'goto-line)
#+end_src

** multiple-cursors
Configure the shortcuts for multiple cursors
#+begin_src emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-S-c C-S-c" . 'mc/edit-lines)
         ("C->" . 'mc/mark-next-like-this)
         ("C-<" . 'mc/mark-previous-like-this)
         ("C-c C->" . 'mc/mark-all-like-this)))
#+end_src

** ace-jump-mode
Let's one jump around text
#+begin_src emacs-lisp
(use-package ace-jump-mode
  :ensure t
  :bind (("C-c C-SPC" . 'ace-jump-mode)
         ("C-c C-DEL" . 'ace-jump-mode-pop-mark)))
#+end_src

** Hydra
#+begin_src emacs-lisp
  (use-package hydra
    :ensure t)
#+end_src

* Editing Style
** No tabs, ever. No trailing spaces either.
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq require-final-newline t)
(setq next-line-add-newlines nil)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

** Mark the 80 cols boundary
#+begin_src emacs-lisp
  (use-package column-enforce-mode
    :ensure t
    :config
    (setq column-enforce-column 80)
    :bind ("C-c m" . 'column-enforce-mode))
  ;; column-enforce-face
#+end_src

** Better kill ring
Seen demonstrated by [[https://www.youtube.com/watch?v=LFXA089Tx38][Uncle Dave]]
#+begin_src emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+end_src

* Cool Packages
** annotate-mode
The file-annotations are store externally. Seems to fail with =args-out-of-range= and then Emacs is confused. (filed issue for this)

Also, it seems to interfere with colorful modes like =magit= or =org-agenda-mode= so that I went with a whitelist instead of the wish of a blacklist of modes.

#+begin_src emacs-lisp
(use-package annotate
  :ensure t
  :bind ("C-c C-A" . 'annotate-annotate)  ;; for ledger-mode, as 'C-c C-a' is taken there.
  :config
  (add-hook 'org-mode 'annotate-mode)
  (add-hook 'csv-mode 'annotate-mode)
  (add-hook 'c-mode 'annotate-mode)
  (add-hook 'c++-mode 'annotate-mode)
  (add-hook 'sh-mode 'annotate-mode)
  (add-hook 'ledger-mode 'annotate-mode)
;;;  (define-globalized-minor-mode global-annotate-mode annotate-mode
;;;    (lambda () (annotate-mode 1)))
;;;  (global-annotate-mode 1)
  )
#+end_src

** web-mode
web-mode with config for Polymer editing
#+begin_src emacs-lisp
(use-package web-mode
  :ensure t
  :mode "\\.html\\'"
  :config
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2))
#+end_src

** typescript-mode
#+begin_src emacs-lisp
  (use-package typescript-mode
    :ensure t
    :mode "\\.ts\\'"
    ;; :config
    ;; (setq typescript-indent-level 2)
    )
#+end_src

** csv-mode
mode to edit CSV files.
#+begin_src emacs-lisp
  (use-package csv-mode
    :ensure t
    :mode "\\.csv\\'")
#+end_src

** protobuf-mode
Mode for Google protocol buffer mode
#+begin_src emacs-lisp
  (use-package protobuf-mode
    :ensure t
    :mode "\\.proto\\'")
#+end_src

** Helm (list completion)
Trying out Helm instead of icicles, as it is available on ELPA.

I just took over the config described in this [[https://tuhdo.github.io/helm-intro.html][helm intro]].

IND
#+begin_src emacs-lisp
  (use-package helm
   :ensure t
   :config
    (require 'helm-config)
    ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
    ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
    ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (global-unset-key (kbd "C-x c"))

    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB work in terminal
    (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

    (when (executable-find "curl")
      (setq helm-net-prefer-curl t))

    (setq helm-split-window-inside-p            t ; open helm buffer inside current window, not occupy whole other window
          helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
          helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
          helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
          helm-ff-file-name-history-use-recentf t
          helm-echo-input-in-header-line t)

    (setq helm-autoresize-max-height 0)
    (setq helm-autoresize-min-height 20)
    (helm-autoresize-mode 1)

    (global-set-key (kbd "M-x") 'helm-M-x)
    (helm-mode 1))
#+end_src

#+begin_src emacs-lisp :tangle no
(defun spacemacs//helm-hide-minibuffer-maybe ()
  "Hide minibuffer in Helm session if we use the header line as input field."
  (when (with-helm-buffer helm-echo-input-in-header-line)
    (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
      (overlay-put ov 'window (selected-window))
      (overlay-put ov 'face
                   (let ((bg-color (face-background 'default nil)))
                     `(:background ,bg-color :foreground ,bg-color)))
      (setq-local cursor-type nil))))


(add-hook 'helm-minibuffer-set-up-hook
          'spacemacs//helm-hide-minibuffer-maybe)
#+end_src

** rainbow-mode
Colorize color names and hexadecimal codes in the correct color.
#+begin_src emacs-lisp
(use-package rainbow-mode
  :ensure t)
#+end_src

** taskjuggler-mode (tj3-mode)
#+begin_src emacs-lisp
  (use-package ox-taskjuggler
    :load-path "~/Emacs/lisp")

  (use-package tj3-mode
    :ensure t
    :after ox-taskjuggler
    :config
    (require 'ox-taskjuggler)
    (custom-set-variables
     '(org-taskjuggler-process-command "/usr/bin/tj3 --silent --no-color --output-dir %o %f")
     '(org-taskjuggler-project-tag "PRJ")))
#+end_src

#+begin_src bash :tangle install_deps.sh
# Install TaskJuggler
  if [[ "$(uname -m)" == "x86_64" ]]; then
    install_pkg tj3
  fi
#+end_src

** writeroom-mode
#+begin_src emacs-lisp
(use-package writeroom-mode
  :ensure t
  :init
  (global-set-key (kbd "C-p w") 'writeroom-mode))
#+end_src

** wgrep-mode
#+begin_src emacs-lisp
(use-package wgrep
  :ensure t)
#+end_src

** [[https://github.com/ledger/ledger-mode][ledger-mode]]
*** Cleanup ledger file
#+begin_src emacs-lisp
(defun single-lines-only ()
  "replace multiple blank lines with a single one"
  (interactive)
  (goto-char (point-min))
  (while (re-search-forward "\\(^\\s-*$\\)\n" nil t)
    (replace-match "\n")
    (forward-char 1)))

(defun paf/cleanup-ledger-buffer ()
  "Cleanup the ledger file"
  (interactive)
  (delete-trailing-whitespace)
  (single-lines-only)
  (ledger-mode-clean-buffer)
  (ledger-sort-buffer))
#+end_src

*** Compute formatted sum of region
It actually computes the entire arithmetic expression that is selected, and replaces it with the numerical result.
#+begin_src emacs-lisp
  (defun apply-function-to-region (fn)
    (interactive "XFunction to apply to region: ")
    (save-excursion
      (let* ((beg (region-beginning))
             (end (region-end))
             (had-region (use-region-p))
             (resulting-text
              (funcall
               fn
               (buffer-substring-no-properties beg end)))
             (new-end (+ beg (length resulting-text))))
        (kill-region beg end)
        (insert resulting-text)
        ;; set the active region again if it was set originally.
        (if had-region
            (progn
              (goto-char beg)
              (push-mark new-end)
              (setq mark-active t))))))

  (defun paf/sum-amount (expression)
    "Computes the sum from the arith expression given as argument."
    (format "%.2f" (string-to-number (calc-eval expression))))

  (defun paf/sum-amount-of-region ()
    "Takes the region as an arithmetic expr, and replaces it with its sum."
    (interactive)
    (if (use-region-p)
        (progn
          (apply-function-to-region 'paf/sum-amount)
          (goto-char (region-end)))))

  (global-set-key (kbd "C-p S") 'paf/sum-amount-of-region)
#+end_src

*** Setup
#+begin_src emacs-lisp
  (use-package ledger-mode
    :ensure t
    :bind ("<f6>" . 'paf/cleanup-ledger-buffer)
    :config
    (setq ledger-reconcile-default-commodity "CHF")
    :init
    (add-hook 'ledger-mode-hook
              (lambda ()
                (setq-local tab-always-indent 'complete)
                (setq-local completion-cycle-threshold t)
                (setq-local ledger-complete-in-steps t))))
#+end_src

** [[http://www.gnu.org/software/hyperbole/][hyperbole]]
I found some gems that explain a bit better what hyperbole is trying to solve. See John Wiegley's [[https://www.reddit.com/r/emacs/comments/7daneo/announce_gnu_hyperbole_7_aka_the_git_ready_for/dpx5sxw/][Using hyperbole: a motivation]]
Once more it shows that the most powerful things are not always the most visible nor the easiest to explain.

*NOTE* assigns =hui-search-web= to =C-c C-/= to not clobber the later used =C-c /= from OrgMode (org-mode sparse trees). This works because hyperbole will first check if the function is already bound to some key before binding it to the coded default.
#+begin_src emacs-lisp
  (use-package hyperbole
    :ensure t
    :config
    (bind-key "C-c C-/" 'hui-search-web)  ;; bind before calling require
    (custom-set-faces
     '(hbut ((t (:foreground "green yellow"))) t)
     '(hbut-flash ((t (:background "green yellow"
                       :foreground "dark gray"))) t))
    (require 'hyperbole)
    (load-file "~/Emacs/lisp/hyperbole-systems.el"))
#+end_src

** [[https://github.com/fourier/ztree#ztree][ztree]]
A tree-view navigation of files, with diff tool for directories.
#+begin_src emacs-lisp :tangle no
  (use-package ztree
    :ensure t)
#+end_src

* Coding
** VCS
*** magit
Add the powerful Magit
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :defer
    :bind ("C-x g" . 'magit-status))
  (use-package magit-todos
    :ensure t
    :defer)
#+end_src

** Projectile
Start using projectile. It has the documentation [[https://docs.projectile.mx/en/latest/][here]].
#+begin_src emacs-lisp
  (defun paf/projectile-relative-buf-name ()
    (ignore-errors
      (rename-buffer
       (file-relative-name buffer-file-name (projectile-project-root)))))

  (use-package projectile
    :ensure t
    :config
    (projectile-mode 1)
    (setq projectile-sort-order 'modification-time)
    (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
    (add-hook 'find-file-hook 'paf/projectile-relative-buf-name))

  (use-package helm-projectile
    :ensure t
    :after (projectile helm)
    :requires projectile
    :config
    (helm-projectile-on))

  (use-package persp-projectile
    :ensure t
    :after (perspective projectile)
    :requires persp-projectile)
#+end_src

Also make sure we do have the faster [[https://github.com/ggreer/the_silver_searcher#the-silver-searcher][silver searcher]] version.  This may need you to install the corresponding tool for this, with the following snippet:
#+begin_src bash :tangle install_deps.sh
# helm-ag uses this for faster grepping
if [[ "$(uname)" == "Darwin" ]]; then
  install_pkg -x ag the_silver_searcher
else
  install_pkg -x ag silversearcher-ag
fi
#+end_src

Search the entire project with =C-c p s s= for a regexp. This let's you turn the matching results into an editable buffer using =C-c C-e=. Other keys are listed [[https://github.com/syohex/emacs-helm-ag#keymap][here]].

#+begin_src emacs-lisp
  (use-package ag
    :ensure t)

  (use-package helm-ag
    :ensure t)
#+end_src
** header/implementation toggle
Switch from header to implementation file quickly.
#+begin_src emacs-lisp
(add-hook 'c-mode-common-hook
          (lambda ()
            (local-set-key  (kbd "C-c o") 'ff-find-other-file)))
#+end_src

** no indentation of namespaces in C++
Essentially, use the Google C++ style formatting.
#+begin_src emacs-lisp
  (use-package google-c-style
    :ensure t
    :config
    (add-hook 'c-mode-common-hook 'google-set-c-style)
    (add-hook 'c-mode-common-hook 'google-make-newline-indent))

  ;;(use-package flymake-google-cpplint
  ;;  :ensure t)
#+end_src

** ripgrep
This enables searching recursively in projects.
#+begin_src bash :tangle install_deps.sh
# This can be used by helm-ag for faster grepping
install_pkg -x rg ripgrep
#+end_src

#+begin_src emacs-lisp
  (use-package ripgrep
    :ensure t)
  (use-package projectile-ripgrep
    :ensure t
    :requires (ripgrep projectile))
#+end_src

** Deduplicate and sort
Help cleanup the includes and using lists.
[[http://www.emacswiki.org/emacs/DuplicateLines][found here]]
#+begin_src emacs-lisp
(defun uniquify-region-lines (beg end)
  "Remove duplicate adjacent lines in region."
  (interactive "*r")
  (save-excursion
    (goto-char beg)
    (while (re-search-forward "^\\(.*\n\\)\\1+" end t)
      (replace-match "\\1"))))

(defun paf/sort-and-uniquify-region ()
  "Remove duplicates and sort lines in region."
  (interactive)
  (sort-lines nil (region-beginning) (region-end))
  (uniquify-region-lines (region-beginning) (region-end)))
#+end_src

Simplify cleanup of =#include= / =typedef= / =using= blocks.
#+begin_src emacs-lisp
(global-set-key (kbd "C-p s") 'paf/sort-and-uniquify-region)
#+end_src

** diffing
[[https://github.com/justbur/emacs-vdiff][vdiff]] let's one compare buffers or files.
#+begin_src emacs-lisp
  (use-package vdiff
    :ensure t
    :config
    ; This binds commands under the prefix when vdiff is active.
    (define-key vdiff-mode-map (kbd "C-c") vdiff-mode-prefix-map))
#+end_src

** yasnippet / abbrev / auto-yasnippet
The key for yasnippet expansion is for me =S-TAB= to no clash with regular code indentation.
The snippets are mode-dependent. See the [[http://joaotavora.github.io/yasnippet/][full documentation]].

Some of the keys are listed here. The prefix is =C-c &=

| Command                | key after C-c & |
|------------------------+-----------------|
| yas-new-snippet        | C-n             |
| yas-insert-snippet     | C-s             |
| yas-visit-snippet-file | C-v             |

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (setq yas-snippet-dirs
          (list (expand-file-name "Yasnippets" emacs-config-directory)))
    (yas-global-mode 1))

  (use-package auto-yasnippet
    :ensure t
    :after yasnippet
    :config
    (setq aya-case-fold t)
    (bind-key "C-p C-s c" 'aya-create)
    (bind-key "C-p C-s e" 'aya-expand))
#+end_src

For the abbrev mode, that I use only for correcting typos, I set it up in emacs dir.
To add an abbrev after one has typed something wrong, just use =C-x a i g= (add inverse global) to add the actual text that should have been written.

#+begin_src emacs-lisp
  (use-package abbrev
    :config
    (setq abbrev-file-name "~/.emacs.d/abbrev_defs")
    (setq save-abbrevs 'silent)
    (setq-default abbrev-mode t)
    (if (file-exists-p abbrev-file-name)
        (quietly-read-abbrev-file)))
#+end_src

** Selective display
Will fold all text indented more than the position of the cursor at the time the keys are pressed.
#+begin_src emacs-lisp
(defun set-selective-display-dlw (&optional level)
  "Fold text indented more than the cursor.
   If level is set, set the indent level to level.
   0 displays the entire buffer."
  (interactive "P")
  (set-selective-display (or level (current-column))))

(global-set-key (kbd "C-x $") 'set-selective-display-dlw)
#+end_src

** Info in the gutter
*** Line numbers
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (setq-default display-line-number-width 3)
  (global-set-key (kbd "C-p l") 'display-line-numbers-mode)
#+end_src

*** git informations
#+begin_src emacs-lisp
(use-package git-gutter-fringe+
  :ensure t
  :defer
  :if window-system
  :bind ("C-p g" . 'git-gutter+-mode))
#+end_src

** Speedup VCS
Regexp matching directory names that are not under VC's control. The default regexp prevents fruitless and time-consuming attempts to determine the VC status in directories in which filenames are interpreted as hostnames.
#+begin_src emacs-lisp
(defvar locate-dominating-stop-dir-regexp
  "\\`\\(?:[\\/][\\/][^\\/]+\\|/\\(?:net\\|afs\\|\\.\\.\\.\\)/\\)\\'")
#+end_src

** Dealing with numbers
Simple way to increase/decrease a number in code.
#+begin_src emacs-lisp
  (use-package shift-number
    :ensure t
    :bind (("M-+" . shift-number-up)
           ("M-_" . shift-number-down)))
#+end_src

** GDB with many windows
*** TODO Make it so that the source frame placement is forced only when using gdb.

#+begin_src emacs-lisp
  (setq gdb-many-windows t)
  (setq gdb-use-separate-io-buffer t)
#+end_src

This should display the source code always in the same window when debugging.
Found on [[https://stackoverflow.com/questions/39762833/emacsgdb-customization-how-to-display-source-buffer-in-one-window][Stack Overflow]].

#+begin_src emacs-lisp
  (add-to-list 'display-buffer-alist
               (cons 'gdb-source-code-buffer-p
                     (cons 'display-buffer-use-some-window nil)))

  (defun gdb-source-code-buffer-p (bufName action)
    "Return whether BUFNAME is a source code buffer and gdb is running."
    (let ((buf (get-buffer bufName)))
      (and buf
            (boundp 'gud-minor-mode)
            (eq gud-minor-mode 'gdbmi)
            (with-current-buffer buf
              (derived-mode-p buf 'c++-mode 'c-mode)))))
#+end_src

This was the longer and fault version...
#+begin_src emacs-lisp :tangle no
  ; This unfortunately also messes up the regular frame navigation of source code.
  (add-to-list 'display-buffer-alist
               (cons 'cdb-source-code-buffer-p
                     (cons 'display-source-code-buffer nil)))

  (defun cdb-source-code-buffer-p (bufName action)
    "Return whether BUFNAME is a source code buffer."
    (let ((buf (get-buffer bufName)))
      (and buf
           (with-current-buffer buf
             (derived-mode-p buf 'c++-mode 'c-mode 'csharp-mode 'nxml-mode)))))

  (defun display-source-code-buffer (sourceBuf alist)
    "Find a window with source code and set sourceBuf inside it."
    (let* ((curbuf (current-buffer))
           (wincurbuf (get-buffer-window curbuf))
           (win (if (and wincurbuf
                         (derived-mode-p sourceBuf 'c++-mode 'c-mode 'nxml-mode)
                         (derived-mode-p (current-buffer) 'c++-mode 'c-mode 'nxml-mode))
                    wincurbuf
                  (get-window-with-predicate
                   (lambda (window)
                     (let ((bufName (buffer-name (window-buffer window))))
                       (or (cdb-source-code-buffer-p bufName nil)
                           (assoc bufName display-buffer-alist)
                           ))))))) ;; derived-mode-p doesn't work inside this, don't know why...
      (set-window-buffer win sourceBuf)
      win))
#+end_src

Here is my cheatsheet for the keyboard commands:

All prefixed with =C-x C-a=

|------------+----------------------+---------|
| Domain     | Command              | C-<key> |
| <l>        | <l>                  |   <c>   |
|------------+----------------------+---------|
| Breakpoint | set                  |    b    |
|            | temporary            |    t    |
|            | delete               |    d    |
|------------+----------------------+---------|
| Execute    | Next                 |    n    |
|            | Step Into            |    s    |
|            | Return / Finish      |    f    |
|            | Continue (run)       |    r    |
|------------+----------------------+---------|
| Stack      | Up                   |    <    |
|            | Down                 |    >    |
|------------+----------------------+---------|
| Execute    | Until current line   |    u    |
| (rarer)    | Single instruction   |    i    |
|            | Jump to current line |    j    |
|------------+----------------------+---------|
** vterm
#+begin_src emacs-lisp
  (if (not (string-equal system-type "darwin"))
      (progn
        (use-package vterm
          :ensure t
          :init
          (setq vterm-always-compile-module t)
          :config
          (setq vterm-module-cmake-args "-DUSE_SYSTEM_LIBVTERM=no")
          (define-key vterm-mode-map (kbd "<C-backspace>")
            (lambda () (interactive) (vterm-send-key (kbd "C-w")))))

        (use-package vterm-toggle
          :ensure t
          :after vterm)))
#+end_src

#+begin_src bash :tangle install_deps.sh
  # Needed to compile vterm first time
  if [[ "$(uname -o)" == "Android" ]]; then
    install_pkg -x libtool libtool
  else
    install_pkg -x libtool libtool-bin
  fi
  install_pkg -x cmake cmake
  install_pkg -x perl perl

  # Also amend the bash config
  cat >> ${HOME}/.bashrc <<EOF
  # Setup Emacs's VTerm communication
  if [[ "\${INSIDE_EMACS}" = 'vterm' ]] \\
      && [[ -n "\${EMACS_VTERM_PATH}" ]] \\
      && [[ -f "\${EMACS_VTERM_PATH}/etc/emacs-vterm-bash.sh" ]]; then
          source "\${EMACS_VTERM_PATH}/etc/emacs-vterm-bash.sh"
  fi
  EOF
#+end_src

** bazel
Adding support for Bazel
#+begin_src emacs-lisp
  (use-package bazel
    :ensure t)
#+end_src

* OrgMode
Load all my org stuff, but first org-mode itself.
** Init
If variable =org-directory= is not set yet, map it to my home's files. You may set this in the =~/.emacs= to another value, e.g. =(setq org-directory "/ssh:fleury@machine.site.com:OrgFiles")=

*** NEXT This does not seem to work, check out doc about [[https://stackoverflow.com/questions/3806423/how-can-i-get-a-variables-initial-value-in-elisp][defcustom]]
:LOGBOOK:
- State "NEXT"       from              [2019-06-24 Mon 10:10]
:END:
#+begin_src emacs-lisp
    (use-package org
      :ensure nil
      :config
      (if (not (boundp 'org-directory))
          (setq org-directory "~/OrgFiles"))
      (add-hook 'org-mode-hook #'(lambda ()
                                   (visual-line-mode)
                                   (org-indent-mode))))
#+end_src

** Packages / Helper Functions / Tools found on the web / worg
*** org-protocol
Let other tools use emacs client to interact
#+begin_src emacs-lisp
(require 'org-protocol)
#+end_src

*** Org-relative file helper function
#+begin_src emacs-lisp
(defun org-relative (filename)
  "Compute an expanded absolute file path for org files"
  (expand-file-name filename org-directory))
#+end_src

*** Adjust tags on the right

#+begin_src emacs-lisp
  ;; Setting this to t makes org-refile not work...
  (setq org-auto-align-tags nil)
  (setq org-tags-column 75)
#+end_src

**** TODO Update =org-set-tags-to=
:LOGBOOK:
- State "TODO"       from              [2019-01-12 Sat 12:08]
:END:
[[https://orgmode.org/worg/doc.html#org-set-tags-to][=org-set-tags-to=]] is gone, and =org-set-tags= with > 1 args is not working.
Not sure what to replace it with though...

*** Archiving
Make sure archiving preserves the same tree structure, including when archiving subtrees.
This is found on [[https://gist.github.com/edgimar/072d99d8650abe81a9fe7c8687c0c993][github Gist from edgimar]]

**** TODO Does not seem to work with archiving org-gcal files.
:LOGBOOK:
- State "TODO"       from              [2021-06-03 Thu 00:28]
:END:

#+begin_src emacs-lisp :tangle no
  (load-file (expand-file-name "archive-with-ancestors.el"
                               paf-lisp-directory)
  ;; Set the function to use for org-archive-default  (C-c C-x C-a)
  ;;(setq org-archive-location (concat org-directory "/Archive/%s_archive::* Archived"))

  ;; Auto-save the archive buffer
  (setq org-archive-subtree-save-file-p t)

  ;; (setq org-archive-save-context-info '(time etc.))
#+end_src

*** Refresh Agenda
Refresh org-mode agenda regularly.
[[https://orgmode.org/worg/org-hacks.html#orgab827a7][source on worg]]
There are two functions that supposedly do the same.
#+begin_src emacs-lisp
  (defun kiwon/org-agenda-redo-if-visible ()
    "Call org-agenda-redo function even in the non-agenda buffer."
    (interactive)
    (let ((agenda-window (get-buffer-window org-agenda-buffer-name t)))
      (when agenda-window
        (with-selected-window agenda-window (org-agenda-redo)))))
#+end_src

*** Agenda Files
#+begin_src emacs-lisp
  ;; Make sure org-agenda-files is defined.
  (if (not (boundp 'org-agenda-files))
      (setq org-agenda-files (list (expand-file-name org-directory)
                                   (expand-file-name "Auto" org-directory))))

  (defun org-get-first-agenda-file ()
    (interactive)
    (let* ((num-files (length org-agenda-files))
           (the-file (if (eq num-files 0)
                         org-directory
                       (elt org-agenda-files 0))))
      (find-file the-file)))
#+end_src

*** org-gtasks
Should follow this git repo: [[https://github.com/JulienMasson/org-gtasks][org-gtasks]]
I have copied a version of the file here, it's not yet available on MELPA.

To help debug, use this before running things:
=(setq request-log-level 'debug)=

#+begin_src emacs-lisp
  (use-package request
    :ensure t)
  (use-package deferred
    :ensure t)
  (use-package request-deferred
    :ensure t)
  (load-file (expand-file-name "org-gtasks.el" paf-lisp-directory))

  ;; Helper to sync all task lists for an account
  (defun paf/org-gtasks-sync (account_name)
    "Synchronizes all tasklists for the account with given name."
    (interactive)
    (let* ((account (org-gtasks-find-account-by-name account_name)))
      (org-gtasks-pull account "ALL")
      (org-gtasks-push account "ALL")))
#+end_src

I have this currently in my `~/.emacs`:
#+begin_src emacs-lisp :tangle no
(use-package org-gtasks
  :init
  (org-gtasks-register-account
     :name "pascal"
     :directory "~/OrgFiles/GTasks/"
     :client-id "XXX"
     :client-secret "XXX"))
#+end_src
*** Search in org
**** org-rifle
[[https://github.com/alphapapa/org-rifle][org-rifle]] is the swiss-army knife for searching in an org-file.

#+begin_src emacs-lisp
  (use-package helm-org-rifle
    :ensure t
    :defer 110
    :after org
    )
#+end_src

*** org-super-agenda
This enables a more fine-grained filtering of the agenda items.
#+begin_src emacs-lisp
  (use-package org-super-agenda
    :ensure t
    :config
    (org-super-agenda-mode t))
#+end_src

*** org-roam (v2)
My cheat sheet for =org-roam=

All keys prefixed with =C-c n=

|-------------------+---------------|
| Function          | =C-c n <key>= |
| <l>               |      <c>      |
|-------------------+---------------|
| Toggle side panel |       l       |
|-------------------+---------------|
| Find/create       |       f       |
| Insert link       |       i       |
| Capture           |       c       |
|-------------------+---------------|
| Graph             |       g       |
| Switch to buffer  |       b       |
|-------------------+---------------|


#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :custom
    (org-roam-directory (file-truename (org-relative "OrgRoam")))
    :init (setq org-roam-v2-ack t)
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n b" . org-roam-switch-to-buffer)
           ("C-c n f" . org-roam-node-find)
           ("C-c n c" . org-roam-capture)
           ("C-c n g" . org-roam-graph)
           ("C-c n j" . org-roam-dailies-capture-today)
           ("C-c n i" . org-roam-node-insert))
    :config
    (org-roam-db-autosync-enable)
    ;; if using the org-roam-protocol
    (require 'org-roam-protocol))

  ;;(use-package company-org-roam
  ;;  :ensure t
  ;;  :after org-roam)
#+end_src

These are some extensions to make org-agenda find info in roma files in a reasonable time.
**** TODO This is currently broken as OrgRoam V2 has changed in a non-backwards-compatible way...
:LOGBOOK:
- State "TODO"       from              [2021-07-22 Thu 16:09]
:END:

#+begin_src emacs-lisp
  (use-package org-roam-extras
    :load-path (lambda () (expand-file-name "org-roam-extras.el" paf-lisp-directory))
    :after org-roam
    :config
    (setq roam-extras-todo-tag-name "project")
    ;; set the todo tag to roam fiels when they contain tasks
    ;;;(add-hook 'org-roam-file-setup-hook #'roam-extras/update-todo-tag)
    ;;;(add-hook 'before-save-hook #'roam-extras/update-todo-tag)
    ;; update the agenda-files just before constructing the agenda
    ;;;(advice-add 'org-agenda :before #'roam-extras/add-todo-files)
    ;;;(advice-add 'org-agenda :after #'roam-extras/restore-todo-files)
    )
#+end_src

EmacSQL will need to get its C-binary compiled, and needs supporting tools. Note that 'tcc' for Termux seems not complete enough for the job.
#+begin_src bash :tangle install_deps.sh
  # org-roam needs this binary
  if [[ "$(uname -o)" == "Android" ]]; then
      install_pkg -x sqlite3 sqlite
  else
      install_pkg -x sqlite3 sqlite3
  fi
  # Make sure there is a C compiler for emacsql-sqlite
  [[ -n "$(which cc)" ]] || install_pkg -x cc clang
#+end_src
*** org-ref
#+begin_src emacs-lisp
  (use-package org-ref
    :ensure t)
#+end_src

*** org-clock-convenience
#+begin_src emacs-lisp
  (use-package org-clock-convenience
    :ensure t
    :bind (:map org-agenda-mode-map
             ("<S-right>" . org-clock-convenience-timestamp-up)
             ("<S-left>" . org-clock-convenience-timestamp-down)
             ("[" . org-clock-convenience-fill-gap)
             ("]" . org-clock-convenience-fill-gap-both)))
#+end_src

*** org-kanban
#+begin_src emacs-lisp
  ;;(use-package org-kanban
  ;;  :ensure t)
#+end_src

*** org-board
Archive entire sites locally with `wget`.
#+begin_src emacs-lisp
  (use-package org-board
    :ensure t
    :config
    (global-set-key (kbd "C-c o") org-board-keymap))
#+end_src

This is the needed tool used to fetch a URL's content.
#+begin_src bash :tangle install_deps.sh
# wget used for org-board archiving.
install_pkg -x wget wget
#+end_src

*** org-reveal
This presentation generator is still under review (by me).

#+begin_src bash :noweb yes :tangle install_deps.sh
# Install reveal.js
if [[ -d "${HOME}/reveal.js" ]]; then
  echo "Reveal already installed"
else
  (cd ~/ && git clone https://github.com/hakimel/reveal.js.git)
fi
#+end_src

#+begin_src emacs-lisp
  (use-package ox-reveal
    :ensure t
    :after (htmlize)
    :config
    (setq org-reveal-root (expand-file-name "~/reveal.js")))

  (use-package htmlize
    :ensure t)
#+end_src

*** iimage (M-I)
Make the display of images a simple key-stroke away.
#+begin_src emacs-lisp
  (defun paf/org-toggle-iimage-in-org ()
    "display images in your org file"
    (interactive)
    (if (face-underline-p 'org-link)
        (set-face-underline 'org-link nil)
      (set-face-underline 'org-link t))
    (iimage-mode 'toggle))

  (use-package iimage
    :config
    (add-to-list 'iimage-mode-image-regex-alist
                 (cons (concat "\\[\\[file:\\(~?" iimage-mode-image-filename-regex
                               "\\)\\]")  1))
    (add-hook 'org-mode-hook (lambda ()
                               ;; display images
                               (local-set-key "\M-I" 'paf/org-toggle-iimage-in-org)
                              )))
#+end_src

*** Properties collector
Collect properties into tables. See documentation in the file.
#+begin_src emacs-lisp
(load-file (expand-file-name "org-collector.el" paf-lisp-directory))
#+end_src

** My Setup
These are mostly org-config specific to me, myself and I.
*** Key mappings
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c b") 'org-iswitchb)
  ;; added because on Chromoting/i3, Alt-<up> and Alt-<down> are changin window focus.
  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key (kbd "C-<up>") 'org-move-subtree-up)
              (local-set-key (kbd "C-<down>") 'org-move-subtree-down)
              (local-set-key (kbd "C-c l") 'org-store-link)
              (local-set-key (kbd "C-c C-l") 'org-insert-link)))
#+end_src

*** Colors and faces
This colors the code blocks a bit more visibly.
#+begin_src emacs-lisp
  (set-face-attribute 'org-block-begin-line nil :background "gray22")
  (set-face-attribute 'org-block            nil :background "gray22")
  (set-face-attribute 'org-block-end-line   nil :background "gray22")
#+end_src

*** Links by ID
#+begin_src emacs-lisp
  (setq org-id-link-to-org-use-id 'create-if-interactive)
#+end_src

*** Display settings
my config for display.
#+begin_src emacs-lisp
  (setq org-hide-leading-stars 't)
  (setq org-log-done 't)
  (setq org-startup-folded 't)
  (setq org-startup-indented 't)
  (setq org-startup-folded 't)
  (setq org-ellipsis "...")

  (setq org-time-stamp-formats '("<%Y-%m-%d %a>" . "<%Y-%m-%d %a %H:%M>"))
  (setq org-time-stamp-custom-formats '("<%Y-%m-%d %a>" . "<%Y-%m-%d %a %H:%M>"))
#+end_src

#+begin_src emacs-lisp
  (use-package org-indent
    :ensure nil
    :custom
    (org-indent-indentation-per-level 2))
#+end_src

*** org-habit
#+begin_src emacs-lisp
(use-package org-habit
  :config
  (setq org-habit-graph-column 38)
  (setq org-habit-preceding-days 35)
  (setq org-habit-following-days 10)
  (setq org-habit-show-habits-only-for-today nil))
#+end_src

*** bash command
#+begin_src emacs-lisp
(setq org-babel-sh-command "bash")
#+end_src

*** org-clock properties
clock stuff into a drawer.
#+begin_src emacs-lisp
(setq org-clock-into-drawer t)
(setq org-log-into-drawer t)
(setq org-clock-int-drawer "CLOCK")
#+end_src

*** open first agenda file
F12 open the first agenda file
#+begin_src emacs-lisp
  (global-set-key [f12] 'org-get-first-agenda-file)
  ; F12 on Mac OSX displays the dashboard, so add Control F12
  (global-set-key [C-f12] 'org-get-first-agenda-file)
#+end_src

*** org-secretary
This is my version of the org-secretary
#+begin_src emacs-lisp
  (use-package paf-secretary
    :load-path paf-lisp-directory
    :bind (("\C-cw" . paf-sec-set-with)
	   ("\C-cW" . paf-sec-set-where)
	   ("\C-cj" . paf-sec-tag-entry))
    :config
    (setq paf-sec-me "paf"))

    (setq org-tag-alist '(("PRJ" . ?p)
			  ("DESIGNDOC" . ?D)
			  ("Milestone" . ?m)
			  ("DESK" . ?d)
			  ("HOME" . ?h)
			  ("VC" . ?v)))
#+end_src

*** task tracking
Track task dependencies, and dim them in the agenda.
#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
(setq org-agenda-dim-blocked-tasks 'invisible)
#+end_src

*** effort & columns mode
#+begin_src emacs-lisp
(setq org-global-properties
      '(("Effort_ALL". "0 0:10 0:30 1:00 2:00 4:00 8:00 16:00")))
(setq org-columns-default-format
      "%TODO %30ITEM %3PRIORITY %6Effort{:} %10DEADLINE")
#+end_src

*** org-todo keywords
#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t!)" "NEXT(n!)" "STARTED(s!)" "WAITING(w!)" "AI(a!)" "|" "DONE(d!)" "CANCELLED(C@)" "DEFERRED(D@)" "SOMEDAY(S!)" "FAILED(F!)" "REFILED(R!)")
          (sequence "APPLIED(A!)" "WAITING(w!)" "ACCEPTED" "|" "REJECTED" "PUBLISHED")
          (sequence "TASK(m!)" "ACTIVE" "|" "DONE(d!)" "CANCELLED(C@)" )))

  (setq org-tags-exclude-from-inheritance '("PRJ" "REGULAR")
        org-use-property-inheritance '("PRIORITY")
        org-stuck-projects '("+PRJ/-DONE-CANCELLED"
                             ;; it is considered stuck if there is no next action
                             (;"TODO"
                              "NEXT" "STARTED" "TASK") ()))

  (setq org-todo-keyword-faces
        '(
          ("TODO" . (:foreground "purple" :weight bold))
          ("TASK" . (:foreground "steelblue" :weight bold))
          ("NEXT" . (:foreground "red" :weight bold))
          ("STARTED" . (:foreground "green" :weight bold))
          ("WAITING" . (:foreground "orange" :weight bold))
          ("SOMEDAY" . (:foreground "steelblue" :weight bold))
          ("REFILED" . (:foreground "gray"))
          ("MAYBE" . (:foreground "steelblue" :weight bold))
          ("AI" . (:foreground "red" :weight bold))
          ("NEW" . (:foreground "orange" :weight bold))
          ("RUNNING" . (:foreground "orange" :weight bold))
          ("WORKED" . (:foreground "green" :weight bold))
          ("FAILED" . (:foreground "red" :weight bold))
          ;; For publications
          ("APPLIED" . (:foreground "orange" :weight bold))
          ("ACCEPTED" . (:foreground "orange" :weight bold))
          ("REJECTED" . (:foreground "red" :weight bold))
          ("PUBLISHED" . (:foreground "green" :weight bold))
          ;; Other stuff
          ("ACTIVE" . (:foreground "darkgreen" :weight bold))
          ("FLAG_GATED" . (:foreground "orange" :weight bold))
          ))
#+end_src

*** org-agenda
**** views
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        '(("t" "Hot Today" ((agenda "" ((org-agenda-span 'day)))
                            (tags-todo "-with={.+}/WAITING")
                            (tags-todo "-with={.+}+TODO=\"STARTED\"")
                            (tags-todo "/NEXT")))
          ("T" "Team Today" ((agenda "" ((org-agenda-span 'day)))
                             (tags-todo "with={.+}"
                                      ((org-super-agenda-groups
                                        '((:auto-property "with"))))
                                      )))
          ("r" "Recurring" ((tags "REGULAR")
                            (tags-todo "/WAITING")
                            (tags-todo "TODO=\"STARTED\"")
                            (tags-todo "/NEXT")))
          ("n" "Agenda and all TODO's" ((agenda "")
                                        (alltodo "")))
          ("N" "Next actions" tags-todo "-dowith={.+}/!-TASK-TODO"
           ((org-agenda-todo-ignore-scheduled t)))
          ("h" "Work todos" tags-todo "-dowith={.+}/!-TASK"
           ((org-agenda-todo-ignore-scheduled t)))
          ("H" "All work todos" tags-todo "-personal/!-TASK-CANCELLED"
           ((org-agenda-todo-ignore-scheduled nil)))
          ("A" "Work todos with doat or dowith" tags-todo
           "dowith={.+}/!-TASK"
           ((org-agenda-todo-ignore-scheduled nil)))

          ("p" "Tasks with current WITH and WHERE"
           ((tags-todo (paf-sec-replace-with-where "with={$WITH}" ".+")
                       ((org-agenda-overriding-header
                         (paf-sec-replace-with-where "Tasks with $WITH in $WHERE" "anyone" "any place"))
                        (org-super-agenda-groups
                         '((:name "" :pred paf-sec-limit-to-with-where)
                           (:discard (:anything t)))))
                       )))
          ("j" "TODO dowith and TASK with"
           ((org-sec-with-view "TODO dowith")
            (org-sec-stuck-with-view "TALK with")
            (org-sec-where-view "TODO doat")
            (org-sec-assigned-with-view "TASK with")
            (org-sec-stuck-with-view "STUCK with")
            (todo "STARTED")))
          ("J" "Interactive TODO dowith and TASK with"
           ((org-sec-who-view "TODO dowith")))))

  (setq org-agenda-skip-deadline-prewarning-if-scheduled 2)
#+end_src

**** Display location in agenda
From some help on [[https://emacs.stackexchange.com/questions/26249/customize-text-after-task-in-custom-org-agenda-view][this page]] I think this could work:
#+begin_src emacs-lisp
  (defun paf/org-agenda-get-location()
    "Gets the value of the LOCATION property"
    (let ((loc (org-entry-get (point) "LOCATION")))
      (if (> (length loc) 0)
          loc
        "")))
#+end_src

Also, to set this after org-mode has loaded ([[https://emacs.stackexchange.com/questions/19091/how-to-set-org-agenda-prefix-format-before-org-agenda-starts][see here]]):
#+begin_src emacs-lisp :tangle no
  (with-eval-after-load 'org-agenda
    (add-to-list 'org-agenda-prefix-format
                 '(agenda . "  %-12:c%?-12t %(paf/org-agenda-get-location)% s"))
#+end_src

**** text formatting
These are some improved rendering of the calendar view.

First, d12frosted's [[https://d12frosted.io/posts/2020-06-24-task-management-with-roam-vol2.html][post]] handles the category length:
#+begin_src emacs-lisp
  (defun paf/agenda-category (len)
    (paf/truncate-string (or (org-get-category) "") len))
    ;;(paf/truncate-string (roam-extras/extract-agenda-category) len))

  (with-eval-after-load 'org-agenda
    (setq org-agenda-prefix-format
          '((agenda . " %i %-12(paf/agenda-category 12) %(paf/org-agenda-get-location) %?-12t% s")
            (todo . " %i %-12(paf/agenda-category 12) ")
            (tags . " %i %-12(paf/agenda-category 12) ")
            (search . " %i %-12(paf/agenda-category 12) "))))
#+end_src

Displaying a grid of 3 hours seems better, as show by AbstProcDo's [[https://www.reddit.com/r/orgmode/comments/mbs4ia/my_agendatime_grid_segmented_by_3_hours/][post]]:
#+begin_src emacs-lisp
  (setq org-agenda-time-grid
        (quote ((daily today remove-match)
                (600 900 1200 1500 1800 2100)
                " ……………"
                "" ;; ———————————————"
                )))
#+end_src

**** colors and faces
Make the calendar day info a bit more visible and contrasted.
#+begin_src emacs-lisp
;; Faces to make the calendar more colorful.
(custom-set-faces
 '(org-agenda-current-time ((t (:inherit org-time-grid :foreground "yellow" :weight bold))))
 '(org-agenda-date ((t (:inherit org-agenda-structure :background "pale green" :foreground "black" :weight bold))))
 '(org-agenda-date-weekend ((t (:inherit org-agenda-date :background "light blue" :weight bold)))))
#+end_src

**** now marker
A more visible current-time marker in the agenda
#+begin_src emacs-lisp
(setq org-agenda-current-time-string ">>>>>>>>>> NOW <<<<<<<<<<")
#+end_src

**** auto-refresh
#+begin_src emacs-lisp
  ;; will refresh it only if already visible
  (run-at-time nil 180 'kiwon/org-agenda-redo-if-visible)
#+end_src

**** auto-save org files when idle
This will save them regularly when the idle for more than a minute.
#+begin_src emacs-lisp :tangle no
(add-hook 'org-mode-hook
    (lambda () (run-with-idle-timer 600 t 'org-save-all-org-buffers)))
#+end_src

**** export
That's the export function to update the agenda view.
#+begin_src emacs-lisp :tangle no
(setq org-agenda-exporter-settings
      '((ps-number-of-columns 2)
        (ps-portrait-mode t)
        (org-agenda-add-entry-text-maxlines 5)
        (htmlize-output-type 'font)))

(defun dmg-org-update-agenda-file (&optional force)
  (interactive)
  (save-excursion
    (save-window-excursion
      (let ((file "~/www/agenda/agenda.html"))
        (org-agenda-list)
        (org-agenda-write file)))))
#+end_src

*** org-duration
#+begin_src emacs-lisp
  (use-package org-duration
    :config
    (setq org-duration-units
          `(("min" . 1)
            ("h" . 60)
            ("d" . ,(* 60 8))
            ("w" . ,(* 60 8 5))
            ("m" . ,(* 60 8 5 4))
            ("y" . ,(* 60 8 5 4 10)))
          )
    (org-duration-set-regexps))
#+end_src

*** OrgRoam templates
#+begin_src emacs-lisp
  (setq org-roam-capture-templates
        `(("m" "Meeting" entry
           "* %?\n%U\n%^{with}\n"
           :if-new (file+head "Meeting/%<%Y%m%d%H%M%S>-${slug}.org"
                              "#+title: ${title}\n#+filetags: %^{with}\n\n\n")
           :unnarrowed t)
          ("n" "Note" entry
           "* %?"
           :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                              "#+title: ${title}\n#+filetags: draft\n\n\n")
           :unnarrowed t)
          ("r" "Reference" entry
           "* %?\n%U\n\n"
           :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                              "#+title: ${title}\n#+filetags: reference\n\n\n")
           :unnarrowed t)))
#+end_src

*** Capture & refile
Capture and refile stuff, with some templates that I think are useful.

Very nice post on how to get capture templats from a file: [[https://joshrollinswrites.com/help-desk-head-desk/org-capture-in-files/][Org-capture in Files]].

#+begin_src emacs-lisp
  (setq org-default-notes-file (org-relative "Inbox.org"))

  (setq org-capture-templates
        `(("t" "Task"
           entry (file+headline ,(org-relative "Inbox.org") "Tasks")
           "* TODO %?\n%U\n\n%x"
           :clock-resume t)
          ;;
          ("i" "Idea"
           entry (file+headline ,(org-relative "Inbox.org") "Ideas")
           "* SOMEDAY %?\n%U\n\n%x"
           :clock-resume t)
          ;;
          ("m" "Meeting"
           entry (file+headline ,(org-relative "Inbox.org") "Meetings")
           "* %?  :MTG:\n%U\n%^{with}p"
           :clock-in t
           :clock-resume t)
          ;;
          ("s" "Stand-up"
           entry (file+headline ,(org-relative "Inbox.org") "Meetings")
           "* Stand-up  :MTG:\n%U\n\n%?"
           :clock-in t
           :clock-resume t)
          ;;
          ("1" "1:1"
           entry (file+headline ,(org-relative "Inbox.org") "Meetings")
           "* 1:1 %^{With}  :MTG:\n%U\n:PROPERTIES:\n:with: %\\1\n:END:\n\n%?"
           :clock-in t
           :clock-resume t)
          ;;
          ("p" "Talking Point"
           entry (file+headline ,(org-relative "refile.org") "Talking Points")
           "* %?  :TALK:\n%U\n%^{dowith}p"
           :clock-keep t)
          ;;
          ("j" "Journal"
           entry (file+olp+datetree ,(org-relative "journal.org"))
           "* %?\n%U"
           :clock-in t
           :clock-resume t
           :kill-buffer t)))

  ;; show up to 2 levels for refile targets, in all agenda files
  (setq org-refile-targets '((org-agenda-files :maxlevel . 2)))
  (setq org-log-refile t)  ;; will add timestamp when refiled.

  ;; from: http://doc.norang.ca/org-mode.html
  ;; Exclude DONE state tasks from refile targets
  (defun bh/verify-refile-target ()
    "Exclude todo keywords with a done state from refile targets"
    (not (member (nth 2 (org-heading-components)) org-done-keywords)))

  (setq org-refile-target-verify-function 'bh/verify-refile-target)
#+end_src

Implement my own =AI= refiling.
#+begin_src emacs-lisp
  (defun paf/refile-ai-targets ()
    "Does an org-refile-copy of an AI, with some linking and side-effects.

  This does add a link to the original =AI= in the new task, as
  well as mark the =AI= as done, and change the refiled target to a
  =TODO=."
    (interactive)
    (let ((orig-marker (progn
                         (org-back-to-heading)
                         (point-marker)))
          ;; make sure the to-be-filed entry has an ID
          (orig-id (org-id-get-create)))
      (progn
        (let ((org-refile-keep t))
          (org-refile nil nil nil "Move AI"))
        ;; Now go to the refiled-orig and force change the ID
        ;; (as it has been copied)
        (org-id-get-create t) ;; force change
        (org-todo 'done)
        (let ((orig-link (org-store-link nil)))
          (org-refile-goto-last-stored)
          (org-todo "TODO")
          (org-entry-put (point) "AI" orig-link)))
      ;; Now move back to where we started
      (hypb:goto-marker orig-marker)))
#+end_src

*** org-babel
What kind of code block languages do I need
#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate 'nil) ; Don't ask before executing

(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   (R . t)
   (dot . t)
   (emacs-lisp . t)
   (gnuplot . t)
   (python . t)
   (ledger . t)
   ;;(sh . t)
   (latex . t)
   (shell . t)
  ))
#+end_src

*** org-export
Add a few formats to the export functionality of org-mode.

#+begin_src emacs-lisp
  (use-package ox-odt
    :defer)
  (use-package ox-taskjuggler
    :defer)
  (use-package ox-impress-js
    :defer)
#+end_src

*** plant-uml
Tell where PlantUML is to be found. This needs to be downloaded and installed separately, see the [[http://plantuml.com/][PlantUML website]].

You could install the PlantUML JAR file with this snippet:
#+begin_src bash :tangle install_deps.sh
  # Get a version of the PlantUML jar file.
  install_pkg -x wget wget

  URL='http://sourceforge.net/projects/plantuml/files/plantuml.jar/download'
  DIR="${HOME}/Apps"
  if [[ ! -e "${DIR}/plantuml.jar" ]]; then
      [[ -d "${DIR}" ]] || mkdir -p "${DIR}"
      (cd "${DIR}" && wget -O plantuml.jar "${URL}")
      ls -l "${DIR}/plantuml.jar"
  fi
#+end_src

#+RESULTS:
: -rw-r--r--  1 fleury  primarygroup  178 Jun 14 14:22 /Users/fleury/Apps/plantuml.jar

#+begin_src emacs-lisp
(use-package plantuml-mode
 :ensure t
 :config
  (setq plantuml-jar-path "~/Apps/plantuml.jar")
  (setq org-plantuml-jar-path "~/Apps/plantuml.jar")
  ;; Let us edit PlantUML snippets in plantuml-mode within orgmode
  (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
  ;; make it load this language (for export ?)
  (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t)))
  ;; Enable plantuml-mode for PlantUML files
  (add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode)))
#+end_src

*** yankpad
Check out the [[https://kungsgeten.github.io/yankpad.html][blog post]] (and the [[https://kungsgeten.github.io/yankpad13.html][follow-up]]) and the [[https://github.com/Kungsgeten/yankpad][package docs]].
#+begin_src emacs-lisp
  (use-package yankpad
    :ensure t
    :defer
    :init
    (setq yankpad-file (org-relative "Templates/yankpad.org"))
    :config
    (bind-key "C-p y m" 'yankpad-map)
    (bind-key "C-p y e" 'yankpad-expand))
#+end_src

* The End
#+begin_src emacs-lisp
  ;; ============ end of emacs_setup.org ====================
;;  (profiler-stop)
;;  (profiler-report)
#+end_src
