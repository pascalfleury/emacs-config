#+TITLE: Paf's portable Emacs configuration
#+AUTHOR: Pascal Fleury
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

This is my Emacs config. You need to tangle this into a file that then gets loaded by Emacs: =C-c C-v t= [org-babel-tangle]. Below, I also explain how this tangling is automated.

Find extensive documentation about how to do this [[https://github.com/larstvei/dot-emacs][here]].

* Personal Plans
I regularly try out new packages, this is my current list of things being evaluated.
They usually live temporarily in my =~/.emacs= until I am happy, in which case I move their config into this file so that it gets replicated on all machines I work on with Emacs.

** Currently under review
  - [[https://github.com/Kungsgeten/yankpad][yankpad]] + [[https://github.com/joaotavora/yasnippet][yasnippet]]
  - [[https://github.com/yjwen/org-reveal][ox-reveal]] (see [[https://github.com/yjwen/org-reveal#set-the-location-of-revealjs][installation]])


* One-time Initial Setup
I have my config in directory =~/Emacs= which is where I clone this repository. The config setup is maintained purely in the =~/Emacs/emacs_setup.org= file.

In your =~/.emacs= file, all you need to add is

#+NAME: emacs_bootstrap
#+BEGIN_SRC emacs-lisp :tangle dot_emacs.el
;; Loads PAF's emacs setup with bootstrap
(load-file "~/Emacs/emacs_setup.el")
#+END_SRC

** Bootstrap
Initially when cloning this repository, you have the =emacs_setup.org= file, that contains the config that you adapt to your specific setup, and an =emacs_setup.el= with a bootstrap content that will tangle and compile the org file, /and replace itself/. This is useful the very first time.

After that, the config itself should have the hook to re-tangle and re-compile the setup at each save.

Therefore my setup is very easy to install, and it needs these steps:

1. clone this repo into =~/Emacs=
2. add the one line in you =~/.emacs=
3. make sure Emacs re-interprets its init (you could restart it)

It may be that [[https://github.com/jwiegley/use-package][use-package]] is not installed on your setup, so it will first try to install that. After that step, it will also start installing any package that is marked as needed in this config automatically.

The original content of the =emacs_setup.el= is as follows:

#+BEGIN_SRC emacs-lisp :tangle (expand-file-name "emacs_setup.el" temporary-file-directory)
;; This is the initial state of the file to be loaded.
;; It will replace itself with the actual configuration at first run.

(require 'org) ; We can't tangle without org!

(setq config_base (expand-file-name "emacs_setup"
				    (file-name-directory
				     (or load-file-name buffer-file-name))))
(find-file (concat config_base ".org"))        ; Open the configuration
(org-babel-tangle)                             ; tangle it
(load-file (concat config_base ".el"))         ; load it
(byte-compile-file (concat config_base ".el")) ; finally byte-compile it
#+END_SRC

** Recompile all packages
This will force-recompile everything in =~/.emacs.d/elpa/...= Just run =M-:= and then enter this:
#+begin_src emacs-lisp :tangle no
(byte-recompile-directory package-user-dir nil 'force)
#+end_src
or simply =C-x C-e= at the end of that line.

** One-time configure
To preserve the original state of this file when updating the git repos with new config settings, execute the following block once (=C-c C-c=):

#+BEGIN_SRC bash :noweb yes :tangle onetime_setup.sh
  #!/bin/bash
  # Make git ignore the tangled & updated emacs_setup.el
  if [[ -z "$(which git)" ]]; then
    echo "You will need 'git' to be installed !"
    exit 1
  fi
  if  [[ -z "$(which emacs)" ]]; then
    echo "You might need 'emacs' for this to be useful !"
    exit 1
  fi

  GIT_ROOT=$(dirname $0)
  (cd ${GIT_ROOT} && git update-index --skip-worktree emacs_setup.el)

  # Maybe this is a new install, .emacs does not exist
  test -e ~/.emacs || touch ~/.emacs

  # Initial tangle of files.
  emacs --batch --load ${GIT_ROOT}/emacs_setup.el

  # Add the load-file as the first thing in the user's ~/.emacs
  # If not yet added.
  declare lines=$(grep ';; dot_emacs.el' ~/.emacs | wc -l)
  if (( lines < 1 )); then
    echo "Added loading the config in your ~/.emacs"
    echo ";; dot_emacs.el" > ~/.emacs.new
    cat ${GIT_ROOT}/dot_emacs.el >> ~/.emacs.new
    cat ~/.emacs >> ~/.emacs.new
    mv ~/.emacs.new ~/.emacs
  else
    echo "Config in your ~/.emacs already set up!"
  fi

  # Install system dependencies
  echo "Installing dependencies"
  bash ${GIT_ROOT}/install_deps.sh

  echo "Cleanup"
  rm ${GIT_ROOT}/dot_emacs.el
  rm ${GIT_ROOT}/install_deps.sh
#+END_SRC

This script is then used to install the needed packages on the system.
#+BEGIN_SRC bash :noweb yes :tangle install_deps.sh
  #!/bin/bash
  set -e

  # Trick to make it work on Termux
  which "ls" || pkg install debianutils

  # This is a bit of heuristics to find out what the install system is
  # They are attempted in this order, put the least likely first.
  declare -a PKG_MGRS=("pkg" "brew" "apt-get")

  PKG_PREFIX_apt_get="sudo"
  PKG_POSTFIX_apt_get="-y"

  for pkg in "${PKG_MGRS[@]}"; do
      if [[ -x "$(which ${pkg})" ]]; then
          INSTALLER="${pkg}"
          break
      fi
  done
  if [[ -z "${INSTALLER}" ]]; then
      echo "Did not find a suitable installer (tried ${PKG_MGRS[@]})"
      exit 1
  fi

  # This is the function to call to install anything. It can optionally
  # check for a binary and avoid installing if it's found.  install_pkg
  # [-x <binary>] <package>
  function install_pkg() {
      if [[ "$1" == "-x" ]]; then
          local binary="$(which $2)"
          if [[ -n "${binary}" && -x "${binary}" ]]; then
              echo "Found $2 (${binary}), nothing to install for $3."
              return
          fi
          shift 2
      fi

      local token=$(echo -n ${INSTALLER} | tr -c '0-9a-zA-Z_' '_')
      local prefix_var="PKG_PREFIX_${token}"
      local postfix_var="PKG_POSTFIX_${token}"

      echo "Trying: ${INSTALLER} install $*"
      ${!prefix_var} $(which ${INSTALLER}) ${!postfix_var} install "$@"
  }
#+END_SRC

* Initialize Emacs
This section sets up Emacs so it can tangle the config, find =use-package=, and find the ELPA repositories where to get the new packes from.
** Info header
Just to add a little information in the tangled file.
#+BEGIN_SRC emacs-lisp
;; ===== this file was auto-tangled, only edit the emacs_setup.org =====
#+END_SRC

** melpa
Make sure we have the package system initialized before we load anything.
#+BEGIN_SRC emacs-lisp
(require 'package)
(when (< emacs-major-version 27)
  (package-initialize))
#+END_SRC

Adding my choice of packages repositories.
#+NAME melpa-setup
#+BEGIN_SRC emacs-lisp
(setq package-archives '(("org" . "https://orgmode.org/elpa/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("stable-melpa" . "https://stable.melpa.org/packages/")
                         ("gnu" . "https://elpa.gnu.org/packages/")
                         ; ("marmalade" . "https://marmalade-repo.org/packages/")
                        ))
#+END_SRC
** use-package
I use =use-package= for most configuration, and that needs to be at the top of the file.  =use-package= verifies the presence of the requested package, otherwise installs it, and presents convenient sections for configs of variables, key bindings etc. that happen only if the package is actually loaded.

First, make sure it gets installed if it is not there yet.
#+begin_src emacs-lisp
  ;; make sure use-package is installed
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
#+end_src

#+BEGIN_SRC emacs-lisp
(eval-when-compile (require 'use-package))
#+END_SRC
** tangle-this-config
I set this up to tangle the init org-mode file into the actual Emacs init file as soon as I save it.
#+BEGIN_SRC emacs-lisp
(defun tangle-init ()
  "If the current buffer is 'init.org' the code-blocks are
tangled, and the tangled file is compiled."
  (when (equal (buffer-file-name)
               (expand-file-name "~/Emacs/emacs_setup.org"))
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil))
      (org-babel-tangle)
      (byte-compile-file "~/Emacs/emacs_setup.el"))))

(add-hook 'after-save-hook 'tangle-init)
#+END_SRC
** Detect System
Some hints about how to do this are [[http://ergoemacs.org/emacs/elisp_determine_OS_version.html][here]].
#+begin_src emacs-lisp
;; Detect the current system and capabilities
#+end_src
* Personal Initialization
** Clear =C-p= so I can use it as a prefix
Remove =C-p= that I want to use for *me* personally as a prefix.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-p") nil) ;; was 'previous-line'
#+END_SRC

* Helper Functions
** add-hook-run-once
Use instead of add-hook to run it a single time.
[[https://emacs.stackexchange.com/questions/3323/is-there-any-way-to-run-a-hook-function-only-once][found here]]
#+BEGIN_SRC emacs-lisp
(defmacro add-hook-run-once (hook function &optional append local)
  "Like add-hook, but remove the hook after it is called"
  (let ((sym (make-symbol "#once")))
    `(progn
       (defun ,sym ()
         (remove-hook ,hook ',sym ,local)
         (funcall ,function))
       (add-hook ,hook ',sym ,append ,local))))
#+END_SRC
* Environment
** Browser default
#+BEGIN_SRC emacs-lisp
(setq browse-url-generic-program (executable-find "google-chrome")
  browse-url-browser-function 'browse-url-generic)
#+END_SRC
** Setup server
Start the background server, so we can use emacsclient.
#+begin_src emacs-lisp :tangle no
(server-start)
#+end_src
** UTF-8
 Make Emacs request UTF-8 first when pasting stuff.
#+BEGIN_SRC emacs-lisp
(use-package unicode-escape
  :ensure t
  :init
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
(set-language-environment "UTF-8")
#+END_SRC
** Newline (only Unix wanted)
This should automatically convert any files with dos or Mac line endings into Unix style ones. Code found [[https://www.emacswiki.org/emacs/EndOfLineTips][here]].
#+begin_src emacs-lisp
  (defun no-junk-please-we-are-unixish ()
    (let ((coding-str (symbol-name buffer-file-coding-system)))
      (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
        (set-buffer-file-coding-system 'unix))))

  (add-hook 'find-file-hook 'no-junk-please-we-are-unixish)
#+end_src
** auto revert
Use =auto-revert=, which reloads a file if it's updated on disk
and not modified in the buffer.
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+END_SRC

* Managing Buffers
** winner-mode (layout managing)
Enables =winner-mode=. Navigate buffer-window configs with =C-c left= and =C-c right=.
#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC

** eyebrowse (layout managing)
This is supposed to be a better window manager.
#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :ensure t)
#+END_SRC

** toggle-maximize-buffer
Temporarily maximize a buffer.
[[https://gist.github.com/mads379/3402786][found here]]
#+BEGIN_SRC emacs-lisp
(defun toggle-maximize-buffer () "Maximize buffer"
  (interactive)
  (if (= 1 (length (window-list)))
      (jump-to-register '_)
    (progn
      (window-configuration-to-register '_)
      (delete-other-windows))))
#+END_SRC

Map it to a key.
#+BEGIN_SRC emacs-lisp
(global-set-key [M-f8] 'toggle-maximize-buffer)
#+END_SRC
* Colors and Look
** Fontlock
This gets the font coloring switched on for all buffers.
*** TODO Note: this should be the default, maybe this can go ?
:LOGBOOK:
- State "TODO"       from              [2018-11-07 Wed 22:29]
:END:
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC
** In terminal mode
#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (set-background-color "#ffffff")
  (set-foreground-color "#141312"))
#+END_SRC
** In X11 mode: mouse and window title
#+BEGIN_SRC emacs-lisp
(setq frame-title-format "emacs @ %b - %f")
(when window-system
  (mouse-wheel-mode)  ;; enable wheelmouse support by default
  (set-selection-coding-system 'compound-text-with-extensions))
#+END_SRC
** Look: buffer naming
#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :init
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+END_SRC
** Buffer Decorations
Setup the visual cues about the current editing buffer
#+BEGIN_SRC emacs-lisp
(column-number-mode t)
(setq visible-bell t)
(setq scroll-step 1)
(setq-default transient-mark-mode t)  ;; highlight selection
#+END_SRC
** nyan-mode
#+BEGIN_SRC emacs-lisp
(use-package nyan-mode
  :ensure t
  :bind ("C-p n" . 'nyan-mode))
#+END_SRC
** dynamic cursor colors
The cursor is displayed in different colors, depending on overwrite or insert mode.
#+BEGIN_SRC emacs-lisp
(setq hcz-set-cursor-color-color "")
(setq hcz-set-cursor-color-buffer "")

(defun hcz-set-cursor-color-according-to-mode ()
  "change cursor color according to some minor modes."
  ;; set-cursor-color is somewhat costly, so we only call it when needed:
  (let ((color
         (if buffer-read-only "orange"
           (if overwrite-mode "red"
             "green"))))
    (unless (and
             (string= color hcz-set-cursor-color-color)
             (string= (buffer-name) hcz-set-cursor-color-buffer))
      (set-cursor-color (setq hcz-set-cursor-color-color color))
      (setq hcz-set-cursor-color-buffer (buffer-name)))))

(add-hook 'post-command-hook 'hcz-set-cursor-color-according-to-mode)
#+END_SRC
** theme / faces
I really like the high-contract Zenburn theme.
#+BEGIN_SRC emacs-lisp
  (use-package hc-zenburn-theme
    :ensure t)

  ;; This makes some of the faces a bit more contrasted.
  ;; faces for general region highlighting zenburn is too low-key.
  (custom-set-faces
   '(highlight ((t (:background "forest green"))))
   '(region ((t (:background "forest green")))))
#+END_SRC
** delight
Package to remove some info from the mode-line for minor-modes.
#+begin_src emacs-lisp
  (use-package delight
    :ensure t)
#+end_src
** remove some modelines
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :delight)
#+END_SRC
* Key Mappings
** alternate key mappings
Letting one enter chars that are otherwise difficult in e.g. the minibuffer.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-m") 'newline-and-indent)
(global-set-key (kbd "C-j") 'newline)
(global-set-key [delete] 'delete-char)
(global-set-key [kp-delete] 'delete-char)
#+END_SRC
** Macros
#+BEGIN_SRC emacs-lisp
(global-set-key [f3] 'start-kbd-macro)
(global-set-key [f4] 'end-kbd-macro)
(global-set-key [f5] 'call-last-kbd-macro)
#+END_SRC
** Text size
Increase/decrease text size
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "C-+") 'text-scale-increase)
(define-key global-map (kbd "C--") 'text-scale-decrease)
#+END_SRC
** multiple regions
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-M-i") 'iedit-mode)
#+END_SRC
** Moving around buffers
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c <C-left>")  'windmove-left)
(global-set-key (kbd "C-c <C-right>") 'windmove-right)
(global-set-key (kbd "C-c <C-up>")    'windmove-up)
(global-set-key (kbd "C-c <C-down>")  'windmove-down)
(global-set-key (kbd "C-c C-g") 'goto-line)
#+END_SRC
** multiple-cursors
Configure the shortcuts for multiple cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-S-c C-S-c" . 'mc/edit-lines)
         ("C->" . 'mc/mark-next-like-this)
         ("C-<" . 'mc/mark-previous-like-this)
         ("C-c C->" . 'mc/mark-all-like-this)))
#+END_SRC
** ace-jump-mode
Let's one jump around text
#+BEGIN_SRC emacs-lisp
(use-package ace-jump-mode
  :ensure t
  :bind (("C-c C-SPC" . 'ace-jump-mode)
         ("C-c C-DEL" . 'ace-jump-mode-pop-mark)))
#+END_SRC
** Hydra
#+begin_src emacs-lisp
  (use-package hydra
    :ensure t)
#+end_src
* Editing Style
** No tabs, ever. No trailing spaces either.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq require-final-newline t)
(setq next-line-add-newlines nil)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC
** Mark the 80 cols boundary
#+begin_src emacs-lisp
  (use-package column-enforce-mode
    :ensure t
    :config
    (setq column-enforce-column 80)
    :bind ("C-c m" . 'column-enforce-mode))
  ;; column-enforce-face
#+end_src
** Better kill ring
Seen demonstrated by [[https://www.youtube.com/watch?v=LFXA089Tx38][Uncle Dave]]
#+begin_src emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+end_src
* Cool Packages
** annotate-mode
The file-annotations are store externally. Seems to fail with =args-out-of-range= and then Emacs is confused. (filed issue for this)

Also, it seems to interfere with colorful modes like =magit= or =org-agenda-mode= so that I went with a whitelist instead of the wish of a blacklist of modes.

#+BEGIN_SRC emacs-lisp
(use-package annotate
  :ensure t
  :bind ("C-c C-A" . 'annotate-annotate)  ;; for ledger-mode, as 'C-c C-a' is taken there.
  :config
  (add-hook 'org-mode 'annotate-mode)
  (add-hook 'csv-mode 'annotate-mode)
  (add-hook 'c-mode 'annotate-mode)
  (add-hook 'c++-mode 'annotate-mode)
  (add-hook 'sh-mode 'annotate-mode)
  (add-hook 'ledger-mode 'annotate-mode)
;;;  (define-globalized-minor-mode global-annotate-mode annotate-mode
;;;    (lambda () (annotate-mode 1)))
;;;  (global-annotate-mode 1)
  )
#+END_SRC

** web-mode
web-mode with config for Polymer editing
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode "\\.html\\'"
  :config
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2))
#+END_SRC
** csv-mode
mode to edit CSV files.
#+begin_src emacs-lisp
  (use-package csv-mode
    :ensure t
    :mode "\\.csv\\'")
#+end_src
** protobuf-mode
Mode for Google protocol buffer mode
#+begin_src emacs-lisp
  (use-package protobuf-mode
    :ensure t
    :mode "\\.proto\\'")
#+end_src
** Helm (list completion)
Trying out Helm instead of icicles, as it is available on ELPA.

I just took over the config described in this [[https://tuhdo.github.io/helm-intro.html][helm intro]].

#+begin_src emacs-lisp
(use-package helm
 :ensure t
 :delight helm-mode
 :config
  (require 'helm-config)
  ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
  ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
  ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
  (global-set-key (kbd "C-c h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))

  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB work in terminal
  (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))

  (setq helm-split-window-inside-p            t ; open helm buffer inside current window, not occupy whole other window
        helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
        helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
        helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
        helm-ff-file-name-history-use-recentf t
        helm-echo-input-in-header-line t)

  (setq helm-autoresize-max-height 0)
  (setq helm-autoresize-min-height 20)
  (helm-autoresize-mode 1)

  (helm-mode 1)

  (global-set-key (kbd "M-x") 'helm-M-x))
#+end_src

#+begin_src emacs-lisp :tangle no
(defun spacemacs//helm-hide-minibuffer-maybe ()
  "Hide minibuffer in Helm session if we use the header line as input field."
  (when (with-helm-buffer helm-echo-input-in-header-line)
    (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
      (overlay-put ov 'window (selected-window))
      (overlay-put ov 'face
                   (let ((bg-color (face-background 'default nil)))
                     `(:background ,bg-color :foreground ,bg-color)))
      (setq-local cursor-type nil))))


(add-hook 'helm-minibuffer-set-up-hook
          'spacemacs//helm-hide-minibuffer-maybe)
#+end_src

** [[https://github.com/smihica/emmet-mode][emmet-mode]]
Useful abbreviations when coding in HTML.
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
:ensure t)
#+END_SRC
** rainbow-mode
Colorize color names and codes in the correct color.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
:ensure t)
#+END_SRC
** taskjuggler-mode (tj3-mode)
#+BEGIN_SRC emacs-lisp
  (use-package tj3-mode
    :ensure t
    :after org-plus-contrib
    :config
    (require 'ox-taskjuggler)
    (custom-set-variables
     '(org-taskjuggler-process-command "/usr/bin/tj3 --silent --no-color --output-dir %o %f")
     '(org-taskjuggler-project-tag "PRJ")))
#+END_SRC

#+begin_src bash :tangle install_deps.sh
# Install TaskJuggler
  if [[ "$(uname -m)" == "x86_64" ]]; then
    install_pkg tj3
  fi
#+end_src

** writeroom-mode
#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
  :ensure t
  :init
  (global-set-key (kbd "C-p w") 'writeroom-mode))
#+END_SRC

** wgrep-mode
#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :ensure t)
#+END_SRC

** [[https://github.com/ledger/ledger-mode][ledger-mode]]
*** Cleanup ledger file
#+BEGIN_SRC emacs-lisp
(defun single-lines-only ()
  "replace multiple blank lines with a single one"
  (interactive)
  (goto-char (point-min))
  (while (re-search-forward "\\(^\\s-*$\\)\n" nil t)
    (replace-match "\n")
    (forward-char 1)))

(defun paf/cleanup-ledger-buffer ()
  "Cleanup the ledger file"
  (interactive)
  (delete-trailing-whitespace)
  (single-lines-only)
  (ledger-mode-clean-buffer)
  (ledger-sort-buffer))
#+END_SRC
*** Setup
#+BEGIN_SRC emacs-lisp
  (use-package ledger-mode
    :ensure t
    :bind ("<f6>" . 'paf/cleanup-ledger-buffer)
    :config
    (setq ledger-reconcile-default-commodity "CHF")
    :init
    (add-hook 'ledger-mode-hook
              (lambda ()
                (setq-local tab-always-indent 'complete)
                (setq-local completion-cycle-threshold t)
                (setq-local ledger-complete-in-steps t))))
#+END_SRC
** [[http://www.gnu.org/software/hyperbole/][hyperbole]]
Let's try this too, even though I do not quite get the point of this
whole package yet.

*NOTE* assigns =hui-search-web= to =C-c C-/= to not clobber the later used =C-c /= from OrgMode (org-mode sparse trees). This works because hyperbole will first check if the function is already bound to some key before binding it to the coded default.
#+begin_src emacs-lisp
  (use-package hyperbole
    :ensure t
    :config
    (bind-key "C-c C-/" 'hui-search-web)  ;; bind before calling require
    (require 'hyperbole))
#+end_src
** [[https://github.com/fourier/ztree#ztree][ztree]]
A tree-view navigation of files, with diff tool for directories.
#+begin_src emacs-lisp :tangle no
  (use-package ztree
    :ensure t)
#+end_src
** Emacs Application Framework
Tried it, but it fails often. too fiddly.
#+begin_src emacs-lisp :tangle no
  (if (string-equal system-type "gnu/linux")
      (use-package eaf
        :load-path "~/.emacs.d/site-lisp/emacs-application-framework"
        :custom
        (eaf-find-alternate-file-in-dired t)
        :config
        (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
        (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
        (eaf-bind-key take_photo "p" eaf-camera-keybinding)))
#+end_src

#+begin_src bash :tangle install_deps.sh
  if [[ $(uname -m) == 'x86_64' ]]; then
    # Get the application framework
    install_pkg -x git git
    LISPDIR="${HOME}/.emacs.d/site-lisp"
    REPOS="https://github.com/manateelazycat/emacs-application-framework.git"
    [[ -d "${LISPDIR}" ]] || mkdir -p "${LISPDIR}"
    # try initial checkout if not dir yet
    (cd "${LISPDIR}" && [[ -d "emacs-application-framework" ]] || git clone "${REPOS}" --depth=1)
    # otherwise try to update the framework
    (cd "${LISPDIR}/emacs-application-framework" && git pull --rebase)
    # Install dependencies
    install_pkg nodejs
    install_pkg python3-pyqt5
    install_pkg python3-pyqt5.qtwebengine
    install_pkg python3-dbus
    install_pkg wmctrl
    # Install some needed Python packages
    install_pkg -x /usr/bin/pip3 python3-pip
    /usr/bin/pip3 install pymupdf qrcode pynotify qtconsole
  fi
#+end_src

#+begin_src bash :tangle install_deps.sh
  cat >> "${HOME}/.profile" <<EOF

  # Emacs Application Framework:
  # Make sure D-Bus is getting started when logging in.
  ## Test for an existing bus daemon, just to be safe
  if test -z "\$DBUS_SESSION_BUS_ADDRESS" ; then
      ## if not found, launch a new one
      eval \`dbus-launch --sh-syntax --exit-with-session\`
      echo "D-Bus per-session daemon address is: \$DBUS_SESSION_BUS_ADDRESS"
  fi
  EOF
#+end_src

* Coding
** VCS
*** magit
Add the powerful Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :defer
    :bind ("C-x g" . 'magit-status))
  (use-package magit-todos
    :ensure t
    :defer)
#+END_SRC
*** monky
Add the Magit-copy for Mercurial 'monky'
#+begin_src emacs-lisp
  (use-package monky
    :ensure t
    :defer
    :bind ("C-x m" . 'monky-status))
#+end_src
*** Global caller
Have a single binding to call the most appropriate tool given the repository.
#+begin_src emacs-lisp
  (defun paf/vcs-status ()
       (interactive)
       (condition-case nil
           (magit-status-setup-buffer)
         (error (monky-status))))

  (global-set-key (kbd "C-p v") 'paf/vcs-status)
#+end_src

#+RESULTS:
: paf/vcs-status

** Projectile
Start using projectile. It has the documentation [[https://docs.projectile.mx/en/latest/][here]].
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (projectile-mode +1))

  (use-package helm-projectile
    :ensure t
    :after projectile
    :requires projectile
    :delight projectile-mode
    :config
    (helm-projectile-on))
#+end_src

Also make sure we do have the faster [[https://github.com/ggreer/the_silver_searcher#the-silver-searcher][silver searcher]] version.  This may need you to install the corresponding tool for this, with the following snippet:
#+begin_src bash :tangle install_deps.sh
# helm-ag uses this for faster grepping
if [[ "$(uname)" == "Darwin" ]]; then
  install_pkg -x ag the_silver_searcher
else
  install_pkg -x ag silversearcher-ag
fi
#+end_src

Search the entire project with =C-c p s s= for a regexp. This let's you turn the matching results into an editable buffer using =C-c C-e=. Other keys are listed [[https://github.com/syohex/emacs-helm-ag#keymap][here]].

#+begin_src emacs-lisp
  (use-package helm-ag
    :ensure t)
#+end_src
** header/implementation toggle
Switch from header to implementation file quickly.
#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
          (lambda ()
            (local-set-key  (kbd "C-c o") 'ff-find-other-file)))
#+END_SRC
** no indentation of namespaces in C++
Essentially, use the Google C++ style formatting.
#+begin_src emacs-lisp
  (use-package google-c-style
    :ensure t
    :config
    (add-hook 'c-mode-common-hook 'google-set-c-style)
    (add-hook 'c-mode-common-hook 'google-make-newline-indent))

  (use-package flymake-google-cpplint
    :ensure t)
#+end_src
** ripgrep
This enables searching recursively in projects.
#+begin_src bash :tangle install_deps.sh
# This can be used by helm-ag for faster grepping
install_pkg -x rg ripgrep
#+end_src

#+begin_src emacs-lisp
  (use-package ripgrep
    :ensure t)
  (use-package projectile-ripgrep
    :ensure t
    :requires (ripgrep projectile))
#+end_src

** commenting out
Easy commenting out of lines.
#+BEGIN_SRC emacs-lisp
(autoload 'comment-out-region "comment" nil t)
(global-set-key (kbd "C-c q") 'comment-out-region)
#+END_SRC

** Deduplicate and sort
Help cleanup the includes and using lists.
[[http://www.emacswiki.org/emacs/DuplicateLines][found here]]
#+BEGIN_SRC emacs-lisp
(defun uniquify-region-lines (beg end)
  "Remove duplicate adjacent lines in region."
  (interactive "*r")
  (save-excursion
    (goto-char beg)
    (while (re-search-forward "^\\(.*\n\\)\\1+" end t)
      (replace-match "\\1"))))

(defun paf/sort-and-uniquify-region ()
  "Remove duplicates and sort lines in region."
  (interactive)
  (sort-lines nil (region-beginning) (region-end))
  (uniquify-region-lines (region-beginning) (region-end)))
#+END_SRC

Simplify cleanup of =#include= / =typedef= / =using= blocks.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-p s") 'paf/sort-and-uniquify-region)
#+END_SRC

** diffing
[[https://github.com/justbur/emacs-vdiff][vdiff]] let's one compare buffers or files.
#+begin_src emacs-lisp
  (use-package vdiff
    :ensure t
    :config
    ; This binds commands under the prefix when vdiff is active.
    (define-key vdiff-mode-map (kbd "C-c") vdiff-mode-prefix-map))
#+end_src

** yasnippet
Let's first see how far I get with file-based capture templates and yankpad.
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package yasnippet
    :ensure t)
  (use-package auto-yasnippet
    :ensure t
:after yasnippet
    :config
    (bind-key "C-p C-s c" 'aya-create)
    (bind-key "C-p C-s e" 'aya-expand))
#+END_SRC

** Selective display
Will fold all text indented more than the position of the cursor at the time the keys are pressed.
#+BEGIN_SRC emacs-lisp
(defun set-selective-display-dlw (&optional level)
  "Fold text indented more than the cursor.
   If level is set, set the indent level to level.
   0 displays the entire buffer."
  (interactive "P")
  (set-selective-display (or level (current-column))))

(global-set-key "\C-x$" 'set-selective-display-dlw)
#+END_SRC
** Info in the gutter
*** Line numbers
This is bound to change in Emacs 26, as it has built-in support for this and is more efficient.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c C-n") 'linum-mode)
#+END_SRC
*** git informations
#+BEGIN_SRC emacs-lisp
(use-package git-gutter-fringe+
  :ensure t
  :defer
  :if window-system
  :bind ("C-c g" . 'git-gutter+-mode))
#+END_SRC
** Speedup VCS
Regexp matching directory names that are not under VC's control. The default regexp prevents fruitless and time-consuming attempts to determine the VC status in directories in which filenames are interpreted as hostnames.
#+BEGIN_SRC emacs-lisp
(defvar locate-dominating-stop-dir-regexp
  "\\`\\(?:[\\/][\\/][^\\/]+\\|/\\(?:net\\|afs\\|\\.\\.\\.\\)/\\)\\'")
#+END_SRC
** Dealing with numbers
Simple way to increase/decrease a number in code.
#+begin_src emacs-lisp
  (use-package shift-number
    :ensure t
    :bind (("M-+" . shift-number-up)
           ("M-_" . shift-number-down)))
#+end_src
** GDB with many windows
*** TODO Make it so that the source frame placement is forced only when using gdb.

#+BEGIN_SRC emacs-lisp
  (setq gdb-many-windows t)
  (setq gdb-use-separate-io-buffer t)

  (defun easy-gdb-top-of-stack-and-restore-windows ()
    (interactive)
    (switch-to-buffer (gdb-stack-buffer-name))
    (goto-char (point-min))
    (gdb-select-frame)
    (gdb-restore-windows)
    (other-window 2))

  (global-set-key (kbd "C-x C-a C-t") 'easy-gdb-top-of-stack-and-restore-windows)
#+END_SRC

This should display the source code always in the same window when debugging.
Found on [[https://stackoverflow.com/questions/39762833/emacsgdb-customization-how-to-display-source-buffer-in-one-window][Stack Overflow]].
#+begin_src emacs-lisp
  ; This unfortunately also messes up the regular frame navigation of source code.
  ;(add-to-list 'display-buffer-alist
  ;             (cons 'cdb-source-code-buffer-p
  ;                   (cons 'display-source-code-buffer nil)))

  (defun cdb-source-code-buffer-p (bufName action)
    "Return whether BUFNAME is a source code buffer."
    (let ((buf (get-buffer bufName)))
      (and buf
           (with-current-buffer buf
             (derived-mode-p buf 'c++-mode 'c-mode 'csharp-mode 'nxml-mode)))))

  (defun display-source-code-buffer (sourceBuf alist)
    "Find a window with source code and set sourceBuf inside it."
    (let* ((curbuf (current-buffer))
           (wincurbuf (get-buffer-window curbuf))
           (win (if (and wincurbuf
                         (derived-mode-p sourceBuf 'c++-mode 'c-mode 'nxml-mode)
                         (derived-mode-p (current-buffer) 'c++-mode 'c-mode 'nxml-mode))
                    wincurbuf
                  (get-window-with-predicate
                   (lambda (window)
                     (let ((bufName (buffer-name (window-buffer window))))
                       (or (cdb-source-code-buffer-p bufName nil)
                           (assoc bufName display-buffer-alist)
                           ))))))) ;; derived-mode-p doesn't work inside this, don't know why...
      (set-window-buffer win sourceBuf)
      win))
#+end_src

Here is my cheatsheet for the keyboard commands:

All prefixed with =C-x C-a=

|------------+----------------------+---------|
| Domain     | Command              | C-<key> |
| <l>        | <l>                  |   <c>   |
|------------+----------------------+---------|
| Breakpoint | set                  |    b    |
|            | temporary            |    t    |
|            | delete               |    d    |
|------------+----------------------+---------|
| Execute    | Next                 |    n    |
|            | Step Into            |    s    |
|            | Return / Finish      |    f    |
|            | Continue (run)       |    r    |
|------------+----------------------+---------|
| Stack      | Up                   |    <    |
|            | Down                 |    >    |
|------------+----------------------+---------|
| Execute    | Until current line   |    u    |
| (rarer)    | Single instruction   |    i    |
|            | Jump to current line |    j    |
|------------+----------------------+---------|
** vterm
#+begin_src emacs-lisp
  (if (not (string-equal system-type "darwin"))
      (if (not (eq module-file-suffix nil))
          (use-package vterm
            :ensure t
            :config
            (setq vterm-module-cmake-args "-DUSE_SYSTEM_LIBVTERM=no")
            (define-key vterm-mode-map (kbd "<C-backspace>")
              (lambda () (interactive) (vterm-send-key (kbd "C-w")))))))
#+end_src

#+begin_src bash :tangle install_deps.sh
  # Needed to compile vterm first time
  install_pkg -x libtool libtool-bin
  install_pkg -x cmake cmake

  # Also amend the bash config
  cat >> ${HOME}/.bashrc <<EOF
  # Setup Emacs's VTerm communication
  if [[ "\${INSIDE_EMACS}" = 'vterm' ]] \\
      && [[ -n "\${EMACS_VTERM_PATH}" ]] \\
      && [[ -f "\${EMACS_VTERM_PATH}/etc/emacs-vterm-bash.sh" ]]; then
          source "\${EMACS_VTERM_PATH}/etc/emacs-vterm-bash.sh"
  fi
  EOF
#+end_src


* OrgMode
Load all my org stuff, but first org-mode itself.
** Init
If variable =org-directory= is not set yet, map it to my home's files. You may set this in the =~/.emacs= to another value, e.g. =(setq org-directory "/ssh:fleury@machine.site.com:OrgFiles")=

*** NEXT This does not seem to work, check out doc about [[https://stackoverflow.com/questions/3806423/how-can-i-get-a-variables-initial-value-in-elisp][defcustom]]
:LOGBOOK:
- State "NEXT"       from              [2019-06-24 Mon 10:10]
:END:
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure nil
    :delight org-mode
    :config
    (if (not (boundp 'org-directory))
        (setq org-directory "~/OrgFiles"))
    (add-hook 'org-mode-hook #'(lambda ()
                                 (visual-line-mode)
                                 (org-indent-mode))))
#+END_SRC

** Helper Functions / Tools found on the web / worg
*** Open remote org dir
In your =.emacs= just add this to configure the location:

#+begin_src emacs-lisp :tangle no
(setq remote-org-directory "/ssh:fleury@my.hostname.com:OrgFiles")
#+end_src

Then you can use the keyboard shortcut to open that dir.

#+begin_src emacs-lisp
    (defcustom remote-org-directory "~/OrgFiles"
      "Location of remove OrgFile directory, should you have one."
      :type 'string
      :group 'paf)
    (defun paf/open-remote-org-directory ()
      (interactive)
      (find-file remote-org-directory))

    (global-set-key (kbd "C-p r o") 'paf/open-remote-org-directory)
#+end_src

*** org-protocol
Let other tools use emacs client to interact
#+begin_src emacs-lisp
(require 'org-protocol)
#+end_src
*** Org-relative file function
#+BEGIN_SRC emacs-lisp
(defun org-relative-file (filename)
  "Compute an expanded absolute file path for org files"
  (expand-file-name filename org-directory))
#+END_SRC
*** Adjust tags on the right
Dynamically adjust tag position
[[https://orgmode.org/worg/org-hacks.html#org0560357][source on worg]]

#+BEGIN_SRC emacs-lisp
(defun ba/org-adjust-tags-column-reset-tags ()
  "In org-mode buffers it will reset tag position according to
`org-tags-column'."
  (when (and
         (not (string= (buffer-name) "*Remember*"))
         (eql major-mode 'org-mode))
    (let ((b-m-p (buffer-modified-p)))
      (condition-case nil
          (save-excursion
            (goto-char (point-min))
            (command-execute 'outline-next-visible-heading)
            ;; disable (message) that org-set-tags generates
            (cl-letf (((symbol-function 'message) #'format))
              (org-set-tags 1 t))
            (set-buffer-modified-p b-m-p))
        (error nil)))))

(defun ba/org-adjust-tags-column-now ()
  "Right-adjust `org-tags-column' value, then reset tag position."
  (set (make-local-variable 'org-tags-column)
       (- (- (window-width) (length org-ellipsis))))
  (ba/org-adjust-tags-column-reset-tags))

(defun ba/org-adjust-tags-column-maybe ()
  "If `ba/org-adjust-tags-column' is set to non-nil, adjust tags."
  (when ba/org-adjust-tags-column
    (ba/org-adjust-tags-column-now)))

(defun ba/org-adjust-tags-column-before-save ()
  "Tags need to be left-adjusted when saving."
  (when ba/org-adjust-tags-column
     (setq org-tags-column 1)
     (ba/org-adjust-tags-column-reset-tags)))

(defun ba/org-adjust-tags-column-after-save ()
  "Revert left-adjusted tag position done by before-save hook."
  (ba/org-adjust-tags-column-maybe)
  (set-buffer-modified-p nil))

;; between invoking org-refile and displaying the prompt (which
;; triggers window-configuration-change-hook) tags might adjust,
;; which invalidates the org-refile cache
(defadvice org-refile (around org-refile-disable-adjust-tags)
  "Disable dynamically adjusting tags"
  (let ((ba/org-adjust-tags-column nil))
    ad-do-it))
(ad-activate 'org-refile)

;; Now set it up
(setq ba/org-adjust-tags-column t)
;; automatically align tags on right-hand side
;; TODO(fleury): Does not seem to work as of 2017/12/18
;; Seems to work again 2018/11/01
(add-hook 'window-configuration-change-hook
          'ba/org-adjust-tags-column-maybe)
(add-hook 'before-save-hook 'ba/org-adjust-tags-column-before-save)
(add-hook 'after-save-hook 'ba/org-adjust-tags-column-after-save)
(add-hook 'org-agenda-mode-hook (lambda ()
                                  (setq org-agenda-tags-column (- (window-width)))))
#+END_SRC

**** TODO Update =org-set-tags-to=
:LOGBOOK:
- State "TODO"       from              [2019-01-12 Sat 12:08]
:END:
[[https://orgmode.org/worg/doc.html#org-set-tags-to][=org-set-tags-to=]] is gone, and =org-set-tags= with > 1 args is not working.
Not sure what to replace it with though...

*** Preserve structure in archives
Make sure archiving preserves the same tree structure, including when archiving subtrees.
[[https://orgmode.org/worg/org-hacks.html#org4265b4c][source on worg]]

#+BEGIN_SRC emacs-lisp
(defun my-org-inherited-no-file-tags ()
  (let ((tags (org-entry-get nil "ALLTAGS" 'selective))
        (ltags (org-entry-get nil "TAGS")))
    (mapc (lambda (tag)
            (setq tags
                  (replace-regexp-in-string (concat tag ":") "" tags)))
          (append org-file-tags (when ltags (split-string ltags ":" t))))
    (if (string= ":" tags) nil tags)))
#+END_SRC

This used to work, but =org-extract-archive-file= is no longer defined.
#+BEGIN_SRC emacs-lisp :tangle no
(defadvice org-archive-subtree
    (around my-org-archive-subtree-low-level activate)
  (let ((tags (my-org-inherited-no-file-tags))
        (org-archive-location
         (if (save-excursion (org-back-to-heading)
                             (> (org-outline-level) 1))
             (concat (car (split-string org-archive-location "::"))
                     "::* "
                     (car (org-get-outline-path)))
           org-archive-location)))
    ad-do-it
    (with-current-buffer (find-file-noselect (org-extract-archive-file))
      (save-excursion
        (while (org-up-heading-safe))
        (org-set-tags tags)))))
#+END_SRC
*** Auto-Refresh Agenda
Refresh org-mode agenda regularly.
[[https://orgmode.org/worg/org-hacks.html#orgab827a7][source on worg]]
There are two functions that supposedly do the same.
#+BEGIN_SRC emacs-lisp
(defun kiwon/org-agenda-redo-in-other-window ()
  "Call org-agenda-redo function even in the non-agenda buffer."
  (interactive)
  (let ((agenda-window (get-buffer-window org-agenda-buffer-name t)))
    (when agenda-window
      (with-selected-window agenda-window (org-agenda-redo)))))

(defun update-agenda-if-visible ()
  (interactive)
  (let ((buf (get-buffer "*Org Agenda*"))
        wind)
    (if buf
        (org-agenda-redo))))
#+END_SRC
*** Display Agenda when idle
Show the agenda when emacs left idle.
[[https://orgmode.org/worg/org-hacks.html#orgaea636d][source on worg]]
#+BEGIN_SRC emacs-lisp
(defun jump-to-org-agenda ()
  (interactive)
  (let ((buf (get-buffer "*Org Agenda*"))
        wind)
    (if buf
        (if (setq wind (get-buffer-window buf))
            (select-window wind)
          (if (called-interactively-p 'any)
              (progn
                (select-window (display-buffer buf t t))
                (org-fit-window-to-buffer)
                (org-agenda-redo)
                )
            (with-selected-window (display-buffer buf)
              (org-fit-window-to-buffer)
              ;;(org-agenda-redo)
              )))
      (call-interactively 'org-agenda-list)))
  ;;(let ((buf (get-buffer "*Calendar*")))
  ;;  (unless (get-buffer-window buf)
  ;;    (org-agenda-goto-calendar)))
  )
#+END_SRC
*** Display location in agenda
From some help on [[https://emacs.stackexchange.com/questions/26249/customize-text-after-task-in-custom-org-agenda-view][this page]] I think this could work:
#+begin_src emacs-lisp
  (defun paf/org-agenda-get-location()
    "Gets the value of the LOCATION property"
    (let ((loc (org-entry-get (point) "LOCATION")))
      (if (> (length loc) 0)
          loc
        "")))
#+end_src

Also, to set this after org-mode has loaded ([[https://emacs.stackexchange.com/questions/19091/how-to-set-org-agenda-prefix-format-before-org-agenda-starts][see here]]):
#+begin_src emacs-lisp :tangle no
  (with-eval-after-load 'org-agenda
    (add-to-list 'org-agenda-prefix-format
                 '(agenda . "  %-12:c%?-12t %(paf/org-agenda-get-location)% s"))
#+end_src
*** org-gtasks
Should follow this git repo: [[https://github.com/JulienMasson/org-gtasks][org-gtasks]]
I have copied a version of the file here, it's not yet available on MELPA.

To help debug, use this before running things:
=(setq request-log-level 'debug)=

#+begin_src emacs-lisp
  (use-package request
    :ensure t)
  (use-package deferred
    :ensure t)
  (use-package request-deferred
    :ensure t)
  (load-file "~/Emacs/org-gtasks.el")
#+end_src

I have this currently in my `~/.emacs`:
#+begin_src emacs-lisp :tangle no
(use-package org-gtasks
  :init
  (org-gtasks-register-account
     :name "pascal"
     :directory "~/OrgFiles/GTasks/"
     :client-id "XXX"
     :client-secret "XXX"))
#+end_src
*** org-super-agenda
This enables a more fine-grained filtering of the agenda items.
#+begin_src emacs-lisp
  (use-package org-super-agenda
    :ensure t
    :config
    (org-super-agenda-mode t))
#+end_src
*** org-roam
My cheat sheet for =org-roam=

All keys prefixed with =C-c n=

|-------------------+---------------|
| Function          | =C-c n <key>= |
| <l>               |      <c>      |
|-------------------+---------------|
| Toggle side panel |       l       |
|-------------------+---------------|
| Find/create       |       f       |
| Insert link       |       i       |
| Capture           |       c       |
|-------------------+---------------|
| Graph             |       g       |
| Switch to buffer  |       b       |
|-------------------+---------------|


#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :hook (after-init . org-roam-mode)
    :init (setq org-roam-directory
                (org-relative-file "OrgRoam"))
    :bind (:map org-roam-mode-map
                (("C-c n l" . org-roam)
                 ("C-c n b" . org-roam-switch-to-buffer)
                 ("C-c n f" . org-roam-find-file)
                 ("C-c n c" . org-roam-capture)
                 ("C-c n g" . org-roam-graph))
           :map org-mode-map
                (("C-c n i" . org-roam-insert))))

  (use-package company-org-roam
    :ensure t
    :after org-roam)
#+end_src

EmacSQL will need to get its C-binary compiled, and needs supporting tools. Note that 'tcc' for Termux seems not complete enough for the job.
#+begin_src bash :tangle install_deps.sh
# org-roam needs this binary
install_pkg -x sqlite3 sqlite3
# Make sure there is a C compiler for emacsql-sqlite
[[ -n "$(which cc)" ]] || install_pkg -x cc clang
#+end_src

*** org-clock-convenience
#+begin_src emacs-lisp
  (use-package org-clock-convenience
    :ensure t
    :bind (:map org-agenda-mode-map
             ("<S-right>" . org-clock-convenience-timestamp-up)
             ("<S-left>" . org-clock-convenience-timestamp-down)
             ("[" . org-clock-convenience-fill-gap)
             ("]" . org-clock-convenience-fill-gap-both)))
#+end_src
*** org-kanban
#+begin_src emacs-lisp
  ;;(use-package org-kanban
  ;;  :ensure t)
#+end_src
*** org-board
Archive entire sites locally with `wget`.
#+begin_src emacs-lisp
  (use-package org-board
    :ensure t
    :config
    (global-set-key (kbd "C-c o") org-board-keymap))
#+end_src

This is the needed tool used to fetch a URL's content.
#+begin_src bash :tangle install_deps.sh
# wget used for org-board archiving.
install_pkg -x wget wget
#+end_src

*** org-reveal
This presentation generator is still under review (by me).

#+BEGIN_SRC bash :noweb yes :tangle install_deps.sh
# Install reveal.js
if [[ -d "${HOME}/reveal.js" ]]; then
  echo "Reveal already installed"
else
  (cd ~/ && git clone https://github.com/hakimel/reveal.js.git)
fi
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :ensure t
    :after (htmlize)
    :config
    (setq org-reveal-root (expand-file-name "~/reveal.js")))

  (use-package htmlize
    :ensure t)
#+END_SRC

*** iimage (M-I)
Make the display of images a simple key-stroke away.
#+BEGIN_SRC emacs-lisp
  (defun paf/org-toggle-iimage-in-org ()
    "display images in your org file"
    (interactive)
    (if (face-underline-p 'org-link)
        (set-face-underline 'org-link nil)
      (set-face-underline 'org-link t))
    (iimage-mode 'toggle))

  (use-package iimage
    :config
    (add-to-list 'iimage-mode-image-regex-alist
                 (cons (concat "\\[\\[file:\\(~?" iimage-mode-image-filename-regex
                               "\\)\\]")  1))
    (add-hook 'org-mode-hook (lambda ()
                               ;; display images
                               (local-set-key "\M-I" 'paf/org-toggle-iimage-in-org)
                              )))
#+END_SRC
*** Properties collector
Collect properties into tables. See documentation in the file.
#+BEGIN_SRC emacs-lisp
(load-file "~/Emacs/org-collector.el")
#+END_SRC

** My Setup
These are mostly org-config specific to me, myself and I.
*** Key mappings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c b") 'org-iswitchb)

  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key (kbd "C-<up>") 'org-move-subtree-up)
              (local-set-key (kbd "C-<down>") 'org-move-subtree-down)
              (local-set-key (kbd "C-c l") 'org-store-link)
              (local-set-key (kbd "C-c C-l") 'org-insert-link)))

#+END_SRC
*** Display settings
Some config for display.
#+BEGIN_SRC emacs-lisp
(setq org-hide-leading-stars 't)
(setq org-log-done 't)
(setq org-startup-folded 't)
(setq org-startup-indented 't)
(setq org-startup-folded 't)
(setq org-ellipsis "...")
; Don't really like the new bullets though.
;;(use-package 'org-bullets
;;  :config
;;  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

#+begin_src emacs-lisp
  (use-package org-indent
    :ensure nil
    :delight
    :custom
    (org-indent-indentation-per-level 2))
#+end_src
*** org-habit
#+BEGIN_SRC emacs-lisp
(use-package org-habit
  :delight
  :config
  (setq org-habit-graph-column 38)
  (setq org-habit-preceding-days 35)
  (setq org-habit-following-days 10)
  (setq org-habit-show-habits-only-for-today nil))
#+END_SRC
*** bash command
#+BEGIN_SRC emacs-lisp
(setq org-babel-sh-command "bash")
#+END_SRC
*** org-clock properties
clock stuff into a drawer.
#+BEGIN_SRC emacs-lisp
(setq org-clock-into-drawer t)
(setq org-log-into-drawer t)
(setq org-clock-int-drawer "CLOCK")
#+END_SRC
*** open first agenda file
F12 open the first agenda file
#+BEGIN_SRC emacs-lisp
  (defun org-get-first-agenda-file ()
    (interactive)
    (find-file (elt org-agenda-files 0)))
  (global-set-key [f12] 'org-get-first-agenda-file)
  ; F12 on Mac OSX displays the dashboard....
  (global-set-key [C-f12] 'org-get-first-agenda-file)
#+END_SRC
*** org-ehtml [localhost:55555]
This will start serving the org files through the emacs-based webbrowser when pressing =M-f12= (on localhost:55555)
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-ehtml
  :ensure t
  :config
  (setq org-ehtml-docroot (expand-file-name org-directory))
  (setq org-ehtml-everything-editable t)
  (setq org-ehtml-allow-agenda t))

(defun paf/start-web-server ()
  (interactive)
  (ws-start org-ehtml-handler 55555))
(global-set-key (kbd "<M-f12>") 'paf/start-web-server)
#+END_SRC
*** org-link-abbrev
This lets one write links as e.g. [ [b:123457] ]
#+BEGIN_SRC emacs-lisp
(setq org-link-abbrev-alist
      '(("b" . "http://b/")
        ("go" . "http://go/")
        ("cl" . "http://cr/")))
#+END_SRC
*** org-secretary
This is my version of the org-secretary
#+BEGIN_SRC emacs-lisp
    (use-package paf-secretary
      :load-path "~/Emacs"
      :bind (("\C-cw" . paf-sec-set-with)
             ("\C-cW" . paf-sec-set-where)
             ("\C-cj" . paf-sec-tag-entry))
      :config
      (setq paf-sec-me "paf")
      (setq org-tag-alist '(("PRJ" . ?p)
                            ("DESIGNDOC" . ?D)
                            ("Milestone" . ?m)
                            ("DESK" . ?d)
                            ("HOME" . ?h)
                            ("VC" . ?v))))
#+END_SRC
*** task tracking
Track task dependencies, and dim them in the agenda.
#+BEGIN_SRC emacs-lisp
(setq org-enforce-todo-dependencies t)
(setq org-agenda-dim-blocked-tasks 'invisible)
#+END_SRC
*** effort & columns mode
#+BEGIN_SRC emacs-lisp
(setq org-global-properties
      '(("Effort_ALL". "0 0:10 0:30 1:00 2:00 4:00 8:00 16:00")))
(setq org-columns-default-format
      "%TODO %30ITEM %3PRIORITY %6Effort{:} %10DEADLINE")
#+END_SRC
*** org-todo keywords
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t!)" "NEXT(n!)" "STARTED(s!)" "WAITING(w!)" "AI(a!)" "|" "DONE(d!)" "CANCELLED(C@)" "DEFERRED(D@)" "SOMEDAY(S!)" "FAILED(F!)" "REFILED(R!)")
          (sequence "APPLIED(A!)" "WAITING(w!)" "ACCEPTED" "|" "REJECTED" "PUBLISHED")
          (sequence "TASK(m!)" "ACTIVE" "|" "DONE(d!)" "CANCELLED(C@)" )))

  (setq org-tags-exclude-from-inheritance '("PRJ" "REGULAR")
        org-use-property-inheritance '("PRIORITY")
        org-stuck-projects '("+PRJ/-DONE-CANCELLED"
                             ;; it is considered stuck if there is no next action
                             (;"TODO"
                              "NEXT" "STARTED" "TASK") ()))

  (setq org-todo-keyword-faces
        '(
          ("TODO" . (:foreground "purple" :weight bold))
          ("TASK" . (:foreground "steelblue" :weight bold))
          ("NEXT" . (:foreground "red" :weight bold))
          ("STARTED" . (:foreground "green" :weight bold))
          ("WAITING" . (:foreground "orange" :weight bold))
          ("FLAG_GATED" . (:foreground "orange" :weight bold))
          ("SOMEDAY" . (:foreground "steelblue" :weight bold))
          ("MAYBE" . (:foreground "steelblue" :weight bold))
          ("AI" . (:foreground "red" :weight bold))
          ("NEW" . (:foreground "orange" :weight bold))
          ("RUNNING" . (:foreground "orange" :weight bold))
          ("WORKED" . (:foreground "green" :weight bold))
          ("FAILED" . (:foreground "red" :weight bold))
          ("REFILED" . (:foreground "gray"))
          ;; For publications
          ("APPLIED" . (:foreground "orange" :weight bold))
          ("ACCEPTED" . (:foreground "orange" :weight bold))
          ("REJECTED" . (:foreground "red" :weight bold))
          ("PUBLISHED" . (:foreground "green" :weight bold))
          ;; Other stuff
          ("ACTIVE" . (:foreground "darkgreen" :weight bold))
          ))
#+END_SRC
*** org-agenda
**** views
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
        '(("t" "Hot Today" ((agenda "" ((org-agenda-span 'day)))
                            (tags-todo "-with={.+}/WAITING")
                            (tags-todo "-with={.+}+TODO=\"STARTED\"")
                            (tags-todo "/NEXT")))
          ("T" "Team Today" ((agenda "" ((org-agenda-span 'day)))
                             (tags-todo "with={.+}"
                                      ((org-super-agenda-groups
                                        '((:auto-property "with"))))
                                      )))
          ("r" "Recurring" ((tags "REGULAR")
                            (tags-todo "/WAITING")
                            (tags-todo "TODO=\"STARTED\"")
                            (tags-todo "/NEXT")))
          ("n" "Agenda and all TODO's" ((agenda "")
                                        (alltodo "")))
          ("N" "Next actions" tags-todo "-dowith={.+}/!-TASK-TODO"
           ((org-agenda-todo-ignore-scheduled t)))
          ("h" "Work todos" tags-todo "-dowith={.+}/!-TASK"
           ((org-agenda-todo-ignore-scheduled t)))
          ("H" "All work todos" tags-todo "-personal/!-TASK-CANCELLED"
           ((org-agenda-todo-ignore-scheduled nil)))
          ("A" "Work todos with doat or dowith" tags-todo
           "dowith={.+}/!-TASK"
           ((org-agenda-todo-ignore-scheduled nil)))

          ("p" "Tasks with current WITH and WHERE"
           ((tags-todo (paf-sec-replace-with-where "with={$WITH}" ".+")
                       ((org-agenda-overriding-header
                         (paf-sec-replace-with-where "Tasks with $WITH in $WHERE" "anyone" "any place"))
                        (org-super-agenda-groups
                         '((:name "" :pred paf-sec-limit-to-with-where)
                           (:discard (:anything t)))))
                       )))
          ("j" "TODO dowith and TASK with"
           ((org-sec-with-view "TODO dowith")
            (org-sec-stuck-with-view "TALK with")
            (org-sec-where-view "TODO doat")
            (org-sec-assigned-with-view "TASK with")
            (org-sec-stuck-with-view "STUCK with")
            (todo "STARTED")))
          ("J" "Interactive TODO dowith and TASK with"
           ((org-sec-who-view "TODO dowith")))))

  (setq org-agenda-skip-deadline-prewarning-if-scheduled 2)
#+END_SRC
**** delight
#+begin_src emacs-lisp
(delight 'org-agenda-mode)
#+end_src
**** colors and faces
Make the calendar day info a bit more visible and contrasted.
#+begin_src emacs-lisp
;; Faces to make the calendar more colorful.
(custom-set-faces
 '(org-agenda-current-time ((t (:inherit org-time-grid :foreground "yellow" :weight bold))))
 '(org-agenda-date ((t (:inherit org-agenda-structure :background "pale green" :foreground "black" :weight bold))))
 '(org-agenda-date-weekend ((t (:inherit org-agenda-date :background "light blue" :weight bold)))))
#+end_src
**** now marker
A more visible current-time marker in the agenda
#+BEGIN_SRC emacs-lisp
(setq org-agenda-current-time-string ">>>>>>>>>> NOW <<<<<<<<<<")
#+END_SRC
**** auto-refresh
#+BEGIN_SRC emacs-lisp
  ;; will refresh it only if already visible
  (run-at-time nil 180 'update-agenda-if-visible)
  ;;(add-hook 'org-mode-hook
  ;;          (lambda () (run-at-time nil 180 'kiwon/org-agenda-redo-in-other-window)))
#+END_SRC

This would open the agenda if any org file was opened. In the end, I don't like this feature, so it is disabled by not tangling it.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; Make this happen only if we open an org file.
  (add-hook 'org-mode-hook
            (lambda () (run-with-idle-timer 600 t 'jump-to-org-agenda)))
#+END_SRC
**** auto-save org files when idle
This will save them regularly when the idle for more than a minute.
#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'org-mode-hook
    (lambda () (run-with-idle-timer 600 t 'org-save-all-org-buffers)))
#+END_SRC
**** export
That's the export function to update the agenda view.
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-agenda-exporter-settings
      '((ps-number-of-columns 2)
        (ps-portrait-mode t)
        (org-agenda-add-entry-text-maxlines 5)
        (htmlize-output-type 'font)))

(defun dmg-org-update-agenda-file (&optional force)
  (interactive)
  (save-excursion
    (save-window-excursion
      (let ((file "~/www/agenda/agenda.html"))
        (org-agenda-list)
        (org-agenda-write file)))))
#+END_SRC
*** org-duration
#+BEGIN_SRC emacs-lisp
  (use-package org-duration
    :config
    (setq org-duration-units
          `(("min" . 1)
            ("h" . 60)
            ("d" . ,(* 60 8))
            ("w" . ,(* 60 8 5))
            ("m" . ,(* 60 8 5 4))
            ("y" . ,(* 60 8 5 4 10)))
          )
    (org-duration-set-regexps))
#+END_SRC
*** Capture & refile
Capture and refile stuff, with some templates that I think are useful.

Very nice post on how to get capture templats from a file: [[https://joshrollinswrites.com/help-desk-head-desk/org-capture-in-files/][Org-capture in Files]].

#+BEGIN_SRC emacs-lisp
  (setq org-default-notes-file (org-relative-file "Inbox.org"))

  (setq org-capture-templates
        `(("t" "Task"
           entry (file+headline ,(org-relative-file "Inbox.org") "Tasks")
           "* TODO %?\n%U\n\n%x"
           :clock-resume t)
          ;;
          ("i" "Idea"
           entry (file+headline ,(org-relative-file "Inbox.org") "Ideas")
           "* SOMEDAY %?\n%U\n\n%x"
           :clock-resume t)
          ;;
          ("m" "Meeting"
           entry (file+headline ,(org-relative-file "Inbox.org") "Meetings")
           "* %?  :MTG:\n%U\n%^{with}p"
           :clock-in t
           :clock-resume t)
          ;;
          ("s" "Stand-up"
           entry (file+headline ,(org-relative-file "Inbox.org") "Meetings")
           "* Stand-up  :MTG:\n%U\n\n%?"
           :clock-in t
           :clock-resume t)
          ;;
          ("1" "1:1"
           entry (file+headline ,(org-relative-file "Inbox.org") "Meetings")
           "* 1:1 %^{With}  :MTG:\n%U\n:PROPERTIES:\n:with: %\\1\n:END:\n\n%?"
           :clock-in t
           :clock-resume t)
          ;;
          ("p" "Talking Point"
           entry (file+headline ,(org-relative-file "refile.org") "Talking Points")
           "* %?  :TALK:\n%U\n%^{dowith}p"
           :clock-keep t)
          ;;
          ("j" "Journal"
           entry (file+olp+datetree ,(org-relative-file "journal.org"))
           "* %?\n%U"
           :clock-in t
           :clock-resume t
           :kill-buffer t)))

  ;; show up to 2 levels for refile targets, in all agenda files
  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 2))))
  (setq org-log-refile t)  ;; will add timestamp when refiled.

  ;; from: http://doc.norang.ca/org-mode.html
  ;; Exclude DONE state tasks from refile targets
  (defun bh/verify-refile-target ()
    "Exclude todo keywords with a done state from refile targets"
    (not (member (nth 2 (org-heading-components)) org-done-keywords)))
  (setq org-refile-target-verify-function 'bh/verify-refile-target)
#+END_SRC
*** OrgRoam templates
#+begin_src emacs-lisp
(setq org-roam-capture-templates
      `(("m" "Meeting" entry (function org-roam--capture-get-point)
             "* %?\n%U\n%^{with}\n"
             :file-name "meeting/%<%Y%m%d%H%M%S>-${slug}"
             :head "#+title: ${title}\n#+roam_tags: %^{with}\n\n"
             )))

#+end_src
*** org-babel
What kind of code block languages do I need
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate 'nil) ; Don't ask before executing

(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   (R . t)
   (dot . t)
   (emacs-lisp . t)
   (gnuplot . t)
   (python . t)
   (ledger . t)
   ;;(sh . t)
   (latex . t)
   (shell . t)
  ))
#+END_SRC
*** org-export
Add a few formats to the export functionality of org-mode.

#+BEGIN_SRC emacs-lisp
  (use-package ox-odt
    :defer)
  (use-package ox-taskjuggler
    :defer)
  (use-package ox-impress-js
    :defer)
#+END_SRC
*** plant-uml
Tell where PlantUML is to be found. This needs to be downloaded and installed separately, see the [[http://plantuml.com/][PlantUML website]].

You could install the PlantUML JAR file with this snippet:
#+BEGIN_SRC bash :tangle install_deps.sh
  # Get a version of the PlantUML jar file.
  install_pkg -x wget wget

  URL='http://sourceforge.net/projects/plantuml/files/plantuml.jar/download'
  DIR="${HOME}/Apps"
  if [[ ! -e "${DIR}/plantuml.jar" ]]; then
      [[ -d "${DIR}" ]] || mkdir -p "${DIR}"
      (cd "${DIR}" && wget -O plantuml.jar "${URL}")
      ls -l "${DIR}/plantuml.jar"
  fi
#+END_SRC

#+RESULTS:
: -rw-r--r--  1 fleury  primarygroup  178 Jun 14 14:22 /Users/fleury/Apps/plantuml.jar

#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
 :ensure t
 :config
  (setq plantuml-jar-path "~/Apps/plantuml.jar")
  (setq org-plantuml-jar-path "~/Apps/plantuml.jar")
  ;; Let us edit PlantUML snippets in plantuml-mode within orgmode
  (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
  ;; make it load this language (for export ?)
  (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t)))
  ;; Enable plantuml-mode for PlantUML files
  (add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode)))
#+END_SRC

*** PDF-Tools
A bit difficult to find the docs of how to use it, but it seems quite useful.

Disabled, as it causes only trouble to me, and I am not really using it anyway.
#+begin_src emacs-lisp :tangle no
  (use-package pdf-tools
    :if (and (eq system-type 'gnu/linux)  ;; Set it up on Linux
             (not (string-prefix-p "aarch64" system-configuration)))  ;; but not mobile devices
    :pin manual  ;; update only manually
    :config
    ;; initialize
    (pdf-tools-install)
    (setq-default pdf-view-display-size 'fit-page)           ;; Fit to page when opening
    (add-hook 'pdf-view-mode-hook (lambda () (cua-mode 0)))  ;; turn off cua so copy works
    (setq pdf-view-resize-factor 1.1)                        ;; more fine-grained zoom control
    ;; keyboard shortcuts
    (define-key pdf-view-mode-map (kbd "h") 'pdf-annot-add-highlight-markup-annotation)
    (define-key pdf-view-mode-map (kbd "t") 'pdf-annot-add-text-annotation)
    (define-key pdf-view-mode-map (kbd "D") 'pdf-annot-delete))

  (use-package org-pdfview
    :after (pdf-tools)
    :init
    (add-to-list 'org-file-apps '("\\.pdf\\'" . org-pdfview-open))
    (add-to-list 'org-file-apps '("\\.pdf::\\([[:digit:]]+\\)\\'" . org-pdfview-open)))
#+end_src

#+begin_src bash :tangle no :var dummy=install_deps.sh
# For all the native apps related to PDF tools
# I did not sintall it on Max OSX yet.
if [[ "$(uname -m)" == "x86_64" ]]; then
  install_pkg elpa-pdf-tools elpa-pdf-tools-server
fi
#+end_src

#+RESULTS:

*** yankpad
Check out the [[https://kungsgeten.github.io/yankpad.html][blog post]] (and the [[https://kungsgeten.github.io/yankpad13.html][follow-up]]) and the [[https://github.com/Kungsgeten/yankpad][package docs]].
#+begin_src emacs-lisp
  (use-package yankpad
    :ensure t
    :defer
    :init
    (setq yankpad-file (org-relative-file "yankpad.org"))
    :config
    (bind-key "C-p y m" 'yankpad-map)
    (bind-key "C-p y e" 'yankpad-expand))
#+end_src

*** [[https://www.eliasstorms.net/zetteldeft/][Zetteldeft]]
This is a note-taking packages inspired by the principles of the [[https://zettelkasten.de/][Zettelkasten]]
#+begin_src emacs-lisp
  (use-package deft
    :ensure t)
  (use-package avy
    :ensure t)

  (use-package zetteldeft
    :ensure t
    :after (org deft avy)

    :config
    (setq deft-extensions '("org" "md" "txt"))
    (setq deft-directory (org-relative-file "Zettelkasten"))
    (setq deft-recursive t)

    :bind (("C-c z d" . deft)
           ("C-c z D" . zetteldeft-deft-new-search)
           ("C-c z R" . deft-refresh)
           ("C-c z s" . zetteldeft-search-at-point)
           ("C-c z c" . zetteldeft-search-current-id)
           ("C-c z f" . zetteldeft-follow-link)
           ("C-c z F" . zetteldeft-avy-file-search-ace-window)
           ("C-c z l" . zetteldeft-avy-link-search)
           ("C-c z t" . zetteldeft-avy-tag-search)
           ("C-c z T" . zetteldeft-tag-buffer)
           ("C-c z i" . zetteldeft-find-file-id-insert)
           ("C-c z I" . zetteldeft-find-file-full-title-insert)
           ("C-c z o" . zetteldeft-find-file)
           ("C-c z n" . zetteldeft-new-file)
           ("C-c z N" . zetteldeft-new-file-and-link)
           ("C-c z r" . zetteldeft-file-rename))
  )
#+end_src

Update the version by downloading the latest version here:

#+begin_src bash :tangle no
wget https://raw.githubusercontent.com/EFLS/zetteldeft/master/zetteldeft.el -O ~/Emacs/zetteldeft.el
#+end_src

#+RESULTS:
