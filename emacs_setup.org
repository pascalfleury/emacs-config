#+TITLE: Paf's portable Emacs configuration
#+AUTHOR: Pascal Fleury
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle "~/.emacs.d/init.el"

This is my Emacs config. You need to tangle this into a file that then gets loaded by Emacs: =C-c C-v t= [org-babel-tangle]. Below, I also explain how this tangling is automated.

Find extensive documentation about how to do this [[https://github.com/larstvei/dot-emacs][here]].

* Personal Plans
I regularly try out new packages, this is my current list of things being evaluated.
They usually live temporarily in my =~/.emacs= until I am happy, in which case I move their config into this file so that it gets replicated on all machines I work on with Emacs.

** Plan to look at
  - [[https://github.com/gsingh93/ob-bitfield][ob-bitfield]]
  - [[https://github.com/Ice-Cube69/org-project-manager][org-project-manager]]
  - [[https://github.com/arthurcgusmao/unmodified-buffer][unmodified-buffer]]

** Currently under review
  - [[https://github.com/yjwen/org-reveal][ox-reveal]] (see [[https://github.com/yjwen/org-reveal#set-the-location-of-revealjs][installation]])

** Make the config work fine when initially installed
*** DONE F12 does not find any files
CLOSED: [2021-06-04 Fri 22:36]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-06-04 Fri 22:36]
- State "TODO"       from              [2021-02-03 Wed 16:52]
:END:
because nothing is set in the =org-agenda-files=
*** DONE maybe complain when org-directory is not set to an existing directory
CLOSED: [2021-08-19 Thu 16:45]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-08-19 Thu 16:45]
- State "TODO"       from              [2021-02-03 Wed 16:53]
:END:
*** TODO Avoid showing the welcome screen if a file was requested on cmdline
:LOGBOOK:
- State "TODO"       from              [2021-06-04 Fri 23:41]
:END:
*** DONE Tangle the config file into =~/.emacs.d/personal.el= and have =~/.emacs.d/init.el= load that.
CLOSED: [2021-09-13 Mon 23:16]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-09-13 Mon 23:16]
- State "TODO"       from              [2021-08-19 Thu 16:46]
:END:
*** NEXT Shortcuts to access VTerm directly (C-p w t) and toggle it
:LOGBOOK:
- State "NEXT"       from              [2023-11-27 Mon 17:15]
:END:
Some information here:
https://www.reddit.com/r/emacs/comments/tagvgb/how_can_i_create_a_command_to_always_move_focus/

*** NEXT Display the current machine name where the (TRAMP) terminal is running
:LOGBOOK:
- State "NEXT"       from              [2023-11-27 Mon 17:16]
:END:
https://www.reddit.com/r/emacs/comments/utarza/help_getting_vterm_to_work_over_tramp/
https://stackoverflow.com/questions/26630640/tramp-ignores-tramp-remote-path#26649558

*** TODO Have Org be checked into git automatically
:LOGBOOK:
- State "TODO"       from              [2023-11-27 Mon 17:21]
:END:
See Karl Voit's setup.

* Initialize Emacs
This section sets up Emacs so it can tangle the config, find =use-package=, and find the ELPA repositories where to get the new packes from.
** Info header and startup
Just to add a little information in the tangled file.
#+begin_src emacs-lisp
  ;; ===== this file was auto-tangled, only edit the emacs_setup.org =====
  ;; (profiler-start 'cpu)
#+end_src

#+begin_src bash :tangle bash/install_deps.sh :shebang "#!/bin/bash"
  source $(dirname $0)/install.sh
#+end_src

** Diverse paths
A variable so we can refer to this all over the place.

Maybe there is a way to auto-detect this and generate it with literate programming or such.
#+begin_src emacs-lisp
  (setq emacs-config-directory "~/Emacs")
  (setq paf-lisp-directory (expand-file-name "lisp" emacs-config-directory))
  (setq paf-modules-directory (expand-file-name "Modules" emacs-config-directory))
  (setq paf-emacs-init "~/.emacs.d/init.el")
  (setq custom-file "~/.emacs.d/custom.el")
  (setq paf-roam-directory (expand-file-name "OrgRoam" org-directory))
#+end_src

** MELPA
Make sure we have the package system initialized before we load anything.
#+begin_src emacs-lisp
(require 'package)
(when (< emacs-major-version 27)
  (package-initialize))
#+end_src

Adding my choice of packages repositories.

#+NAME melpa-setup
#+begin_src emacs-lisp
    (setq package-archives '(
                             ;;("org" . "https://orgmode.org/elpa/")
                             ("melpa-stable" . "https://stable.melpa.org/packages/")
                             ("melpa" . "https://melpa.org/packages/")
                             ("nongnu" . "https://elpa.nongnu.org/nongnu/")
                             ("gnu" . "https://elpa.gnu.org/packages/")
                             ))
    (setq package-archive-priorities
        '(("melpa-stable" . 20)
          ("nongnu" . 20)
          ("gnu" . 10)
          ("melpa" . -10) ; negative -> no automatic upgrade
          ))
#+end_src

From this [[https://github.com/melpa/melpa/issues/7238][bug report]], seems to work:
#+begin_src emacs-lisp
  ;; avoid the timeouts we get on Mac when updating packages
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+end_src

Note that 'melpa' is needed for these:
 - hc-zenburn-theme
 - column-enforce-mode
 - popup-kill-ring
 - tj3-mode
 - google-c-style
 - git-gutter-fringe+
 - bazel
 - org-clock-convenience
 - ox-reveal

** use-package
I use =use-package= for most configuration, and that needs to be at the top of the file. =use-package= verifies the presence of the requested package, otherwise installs it, and presents convenient sections for configs of variables, key bindings etc. that happen only if the package is actually loaded.

First, make sure it gets installed if it is not there yet.
#+begin_src emacs-lisp
  ;; make sure use-package is installed
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
#+end_src

#+begin_src emacs-lisp
(eval-when-compile (require 'use-package))
#+end_src
** tangle-this-config
I set this up to tangle the init org-mode file into the actual Emacs init file as soon as I save it.
#+begin_src emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are
    tangled, and the tangled file is compiled."
    (when (equal (buffer-file-name)
                 (expand-file-name "emacs_setup.org" emacs-config-directory))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
        (org-babel-tangle)
        ;; (byte-compile-file paf-emacs-init)
        )))

  (add-hook 'after-save-hook 'tangle-init)
#+end_src
** Speedup startup time
*** Temporarily disable GC
#+begin_src emacs-lisp
  ;; Minimize garbage collection during startup
  (setq gc-cons-threshold most-positive-fixnum)

  ;; Lower threshold back to 8 MiB (default is 800kB)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (expt 2 23))))
#+end_src

*** Add the startup profiler
#+begin_src emacs-lisp :tangle no
  (use-package esup
    :ensure t
    :pin stable-melpa)
#+end_src

** Detect System
Some hints about how to do this are [[http://ergoemacs.org/emacs/elisp_determine_OS_version.html][here]].

#+begin_src emacs-lisp
  ;; Detect the current system and capabilities
  (defun paf/macosx-p ()
    "Return non-nil iff Emacs is running on macOS."
    (string-match "apple-darwin" system-configuration))
#+end_src

* Personal Initialization
** Clear =C-p= so I can use it as a prefix
Remove =C-p= that I want to use for *me* personally as a prefix.
#+begin_src emacs-lisp
(global-set-key (kbd "C-p") nil) ;; was 'previous-line'
#+end_src

** Initial scratch content
#+begin_src emacs-lisp
(setq initial-scratch-message "; Paf's unsaved ramblings and tests...\n")
#+end_src

** Splash screen
#+begin_src emacs-lisp
  (defun get-resource (name)
    (let* ((resource-dir (expand-file-name "Resources" emacs-config-directory)))
      (expand-file-name name resource-dir)))
  (if (display-graphic-p)
      (progn
        (setq initial-buffer-choice (get-resource "welcome.org"))
        (setq fancy-splash-image (get-resource "paf_emacs.png"))
        (setq org-startup-with-inline-images t))
    (setq initial-buffer-choice (get-resource "welcome_nox.org")))
#+end_src

** Initial screen position
This configures where the initial window will appear on the screen.
Search for "Window Frame Parameters" in the Elisp  Info manual.

:tangle "~/.emacs.d/early-init.el"
#+begin_src emacs-lisp :tangle no
  ;; Setup the initil frame to be right-aligned and full height.
  (setq default-frame-alist
         '((fullscreen . fullheight)
           (left . (- 1))
           (top . 0)))
#+end_src

** Resize at pixel-level
Otherwise resizing will round it at char width/height and not make it play well with the window manager.
#+begin_src emacs-lisp :tangle "~/.emacs.d/early-init.el"
  (setq frame-resize-pixelwise 't)
#+end_src

* Helper Functions
** add-hook-run-once
Use instead of add-hook to run it a single time.
[[https://emacs.stackexchange.com/questions/3323/is-there-any-way-to-run-a-hook-function-only-once][found here]]
#+begin_src emacs-lisp
(defmacro add-hook-run-once (hook function &optional append local)
  "Like add-hook, but remove the hook after it is called"
  (let ((sym (make-symbol "#once")))
    `(progn
       (defun ,sym ()
         (remove-hook ,hook ',sym ,local)
         (funcall ,function))
       (add-hook ,hook ',sym ,append ,local))))
#+end_src

** truncate a string
#+begin_src emacs-lisp
  (defun paf/truncate-string (text &optional len ellipsis)
    "Truncate the text to a given length.

  When LEN is a number, resulting string is truncated at that length.
  If the length is bigger, then '...' is added at the end.

  Usage example:

    (setq org-agenda-prefix-format
          '((agenda . \" %(paf/truncate-string (roam-extras/extract-agenda-category) 12) %?-12t %12s\")))

  Refer to `org-agenda-prefix-format' for more information."
    (interactive)
    (if (and (numberp len) (> (length text) len))
        (let* ((used-ellipsis (if (eq ellipsis nil) "…" ellipsis))
               (ellipsis-length (length used-ellipsis))
               (short-text (substring text 0 (- len ellipsis-length))))
          (format "%s%s" short-text used-ellipsis))
      text))

  ;; (setq paf-tests/truncate (paf/truncate-string "Here is some long text" 10))
#+end_src

** Kill an Emacs process
#+begin_src emacs-lisp
  (defun paf/delete-process-at-point ()
    (interactive)
    (let ((process (get-text-property (point) 'tabulated-list-id)))
      (cond ((and process
                  (processp process))
             (delete-process process)
             (revert-buffer))
            (t
             (error "no process at point!")))))

  (define-key process-menu-mode-map (kbd "C-k") 'paf/delete-process-at-point)
#+end_src

* Environment
** Browser default
#+begin_src emacs-lisp :tangle no
(setq browse-url-generic-program (executable-find "google-chrome")
  browse-url-browser-function 'browse-url-generic)
#+end_src

** Setup server
Start the background server, so we can use emacsclient.
Check by running =(server-running-p)=.
#+begin_src emacs-lisp
  (require 'server)
  (if (and (fboundp 'server-running-p)
           (not (server-running-p)))
      (server-start))
#+end_src

** UTF-8
 Make Emacs request UTF-8 first when pasting stuff, and in general simply use UTF-8. The rest is legacy anyway, see this chart: [[https://en.wikipedia.org/wiki/UTF-8#/media/File:Unicode_Web_growth.svg][UTF-8 Usage]].
 This setting found in [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Recognize-Coding.html][this page]], albeit after quite some searching.
#+begin_src emacs-lisp
  ;(use-package unicode-escape
  ;  :ensure t
  ;  :init
  ;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
  ;(set-language-environment "UTF-8")
  ;(setq selection-coding-system 'UTF8_STRING)
  ;(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

  (setq x-select-request-type nil) ; will use the default, that prefers UTF8_STRING
  (prefer-coding-system 'utf-8)
  (set-language-environment "UTF-8")
#+end_src

** Newline (only Unix wanted)
This should automatically convert any files with dos or Mac line endings into Unix style ones. Code found [[https://www.emacswiki.org/emacs/EndOfLineTips][here]].
#+begin_src emacs-lisp
  (defun no-junk-please-we-are-unixish ()
    (let ((coding-str (symbol-name buffer-file-coding-system)))
      (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
        (set-buffer-file-coding-system 'unix))))

  (add-hook 'find-file-hook 'no-junk-please-we-are-unixish)
#+end_src

** auto revert
Use =auto-revert=, which reloads a file if it's updated on disk
and not modified in the buffer. Also make it reload dired when new files are added.
#+begin_src emacs-lisp
  (setq global-auto-revert-non-file-buffers t)
  (global-auto-revert-mode 1)
#+end_src

** Restore state
#+begin_src emacs-lisp :tangle no
  (desktop-save-mode 1)
#+end_src

** enable upcase- and downcase-region and narrowing
these got disabled in Emacs 19 (!) because they were considered confusing.
Re-enabling them here.
Use =C-x C-u= and =C-x C-l= to effect them.

#+begin_src emacs-lisp
  (put 'upcase-region 'disabled nil)  ;; C-x C-u
  (put 'downcase-region 'disabled nil)  ;; C-x C-l (lowercase L)

  ;; C-x n <key>. Widen with C-x n w
  (put 'narrow-to-region 'disabled nil)  ; C-x n n
  (put 'narrow-to-defun  'disabled nil)
  (put 'narrow-to-page   'disabled nil)
#+end_src

** Calendar starts on Monday
#+begin_src emacs-lisp
  ;; Calendar starts on Monday
  (setq calendar-week-start-day 1)
  (setq org-gcal-local-timezone "Europe/Zurich")

  ;; org-gcal otherwise ask for a passphrase in a text popup.
  (setenv "GPG_AGENT_INFO")
  (setq plstore-cache-passphrase-for-symmetric-encryption 't)
#+end_src

* Completion
** Vertico
Added the completion framework [[https://github.com/minad/vertico][vertico]] as from the docs, I liked
 1. the writing quaqlity
 2. the fact that they re-use/integrate completely with the built-in completion
 3. the package seems quite orthogonal to other packages, i.e. no need to have a =<project>-vertico= package to be installed (like helm seems to need).

#+begin_src emacs-lisp
  ;; Enable vertico
  (use-package vertico
    :ensure t
    :init
    (vertico-mode)
    ;; (setq vertico-resize t)  ;; Grow and shrink the Vertico minibuffer
    (setq vertico-cycle t) ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
    )

  ;; Use the `orderless' completion style. Additionally enable
  ;; `partial-completion' for file path expansion. `partial-completion' is
  ;; important for wildcard support. Multiple files can be opened at once
  ;; with `find-file' if you enter a wildcard. You may also give the
  ;; `initials' completion style a try.
  (use-package orderless
    :ensure t
    :init
    (setq completion-styles '(substring orderless)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))

  ;; Persist history over Emacs restarts. Vertico sorts by history position.
  (use-package savehist
    :init
    (savehist-mode))

  ;; A few more useful configurations...
  (use-package emacs
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; Alternatively try `consult-completing-read-multiple'.
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    ;;(advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    ;; (setq read-extended-command-predicate
    ;;       #'command-completion-default-include-p)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t))
#+end_src

** Marginalia
Also adding more info in the completion buffers with [[https://github.com/minad/marginalia][Marginalia]].

#+begin_src emacs-lisp
    (use-package marginalia
      :ensure t
      ;; Either bind `marginalia-cycle` globally or only in the minibuffer
      :bind (("M-A" . marginalia-cycle)
             :map minibuffer-local-map
             ("M-A" . marginalia-cycle))
      :init
      (marginalia-mode))
#+end_src

** Consult
This package brings some commands based on build-in search. See [[https://github.com/minad/consult][consult homepage]] for more details.
#+begin_src emacs-lisp
  ;; Example configuration for Consult
  (use-package consult
    :ensure t
    :bind (;; C-c bindings (mode-specific-map)
           ("C-c h" . consult-history)
           ("C-c m" . consult-mode-command)
           ("C-c b" . consult-bookmark)
           ("C-c k" . consult-kmacro)
           ;; C-x bindings (ctl-x-map)
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ("<help> a" . consult-apropos)            ;; orig. apropos-command
           ;; M-g bindings (goto-map)
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings (search-map)
           ("M-s f" . consult-find)
           ("M-s F" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s m" . consult-multi-occur)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch)
           :map isearch-mode-map
           ("M-e" . consult-isearch)                 ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch)               ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi))           ;; needed by consult-line to detect isearch

    :init
    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Optionally replace `completing-read-multiple' with an enhanced version.
    ;;(advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    :config
    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key (kbd "M-."))
    ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme
     :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-recent-file
     consult--source-project-recent-file
     :preview-key (kbd "M-."))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; Optionally configure a function which returns the project root directory.
    ;; There are multiple reasonable alternatives to chose from.
    ;;;; 1. project.el (project-roots)
    ;;(setq consult-project-root-function
    ;;      (lambda ()
    ;;        (when-let (project (project-current))
    ;;          (car (project-roots project)))))
    ;; 2. projectile.el (projectile-project-root)
    (autoload 'projectile-project-root "projectile")
    (setq consult-project-root-function #'projectile-project-root)
    ;;;; 3. vc.el (vc-root-dir)
    ;; (setq consult-project-root-function #'vc-root-dir)
    ;;;; 4. locate-dominating-file
    ;; (setq consult-project-root-function (lambda () (locate-dominating-file "." ".git")))
  )
#+end_src

* Managing Buffers
** Resizing windows
Easier shortcuts for resizing windows
#+begin_src emacs-lisp
  (global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
  (global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
  (global-set-key (kbd "S-C-<down>") 'shrink-window)
  (global-set-key (kbd "S-C-<up>") 'enlarge-window)
#+end_src

** winner-mode
Enables =winner-mode=. Navigate buffer-window configs with =C-c left= and =C-c right=.
#+begin_src emacs-lisp
(winner-mode 1)
#+end_src

** popper.el: deal with popup windows
A minor-mode to deal with lots of popup windows and bring some order in them.
See [[https://github.com/karthink/popper][github:popper]] for more information.
#+begin_src emacs-lisp
  (use-package popper
    :ensure t
    :after projectile
    :bind (("<C-tab>"   . popper-toggle-latest)
           ("<C-S-tab>" . popper-cycle)
           ("<C-M-tab>" . popper-toggle-type))
    :init
    (setq popper-reference-buffers
          '("\\*Messages\\*"
            "\\*Bufler\\*"
            "Output\\*$"
            help-mode
            compilation-mode))
    (setq popper-group-function #'popper-group-by-projectile)
    (popper-mode +1))
#+end_src

** [[https://github.com/nex3/perspective-el][perspective]]
#+begin_src emacs-lisp
  (use-package perspective
    :ensure t
    :bind (("C-x C-b" . persp-list-buffers)
           ("C-x b" . persp-switch-to-buffer*)
           ("C-x k" . persp-kill-buffer*))
    :custom (persp-mode-prefix-key (kbd "C-c M-p"))
    :hook   (kill-emacs-hook . persp-state-save)
    :init   (persp-mode)
    :config (setq persp-state-default-file
                  (expand-file-name "perspective.save" user-emacs-directory)))
#+end_src

** toggle-maximize-buffer
Temporarily maximize a buffer.
[[https://gist.github.com/mads379/3402786][found here]]
#+begin_src emacs-lisp
  (defun paf/toggle-maximize-buffer () "Maximize buffer"
         (interactive)
         (if (= 1 (length (window-list)))
             (jump-to-register '_)
           (progn
             (window-configuration-to-register '_)
             (delete-other-windows))))
  ;;Map it to a key.
  (global-set-key (kbd "M-<f8>") 'paf/toggle-maximize-buffer)
  (global-set-key (kbd "C-F") 'paf/toggle-maximize-buffer)
#+end_src

*** display some buffer in a particulr location

#+begin_src emacs-lisp
  ;; make manual switching buffer behave the same as automatic display.
  (setq switch-to-buffer-obey-display-actions t)

  (defun paf/display-buffer-at-bottom ()
    "Move current buffer to bottom of the frame. Also removes it from the side window."
    (interactive)
    (let ((buffer (current-buffer)))
      (with-current-buffer buffer
        (delete-window)
        (display-buffer-at-bottom
         buffer `((window-parameters . ((mode-line-format. (" " "%b")))))))))

  (defun paf/display-buffer-at-right ()
    "Move current buffer to right side window."
    (interactive)
    (let ((buffer (current-buffer)))
      (with-current-buffer buffer
        (delete-window)
        (display-buffer-in-side-window
         buffer `((side . right)
                  (window-parameters . ((mode-line-format. (" " "%b")))))))))

  (defun paf/display-buffer-reset ()
    "Re-display the buffer according to buffer-alist."
    (interactive)
    (let ((buffer (current-buffer)))
      (with-current-buffer buffer
        (delete-window)
        (display-buffer buffer))))

  (use-package window
    :custom
    (display-buffer-alist
     '(("\\*\\(vterm\\|eat\\).*\\*"
        (display-buffer-in-side-window)
        (window-height . (body-lines . 15))
        (side . bottom)
        (slot . -1)
        (window-parameters . ((no-delete-other-windows . t))))
        ("\\*Org Agenda\\*"
         (display-buffer-in-side-window)
         (window-width . (body-columns . 70))
         (side . right)
         (slot . 0)
         (window-parameters . ((no-delete-other-windows . t)
                               (mode-line-format . ("")))))
        ;(".*\\.org"
        ; (display-buffer-in-side-window)
        ; (window-width . (body-columns . 70))
        ; (side . right)
        ; (slot . 1)
        ; (window-parameters . ((no-delete-other-windows . t)
        ;                       (mode-line-format . ("")))))
        ))
     :bind (("C-x w s" . window-toggle-side-windows)
            ("C-x w b" . paf/display-buffer-at-bottom)
            ("C-x w r" . paf/display-buffer-at-right)
            ("C-x w R" . paf/display-buffer-reset)))

    (defun paf/toggle-calendar-buffer ()
      "Will show/hide the calendar on the side window"
      (interactive)
      (let* ((agenda-buffer-name "*Org Agenda*")
             (agenda (get-buffer agenda-buffer-name)))
        (if agenda
            (if (get-buffer-window agenda 'visible)
                (delete-windows-on agenda)
              (pop-to-buffer agenda))
          (org-agenda))))

    (global-set-key (kbd "C-x w a") 'paf/toggle-calendar-buffer)
    (global-set-key (kbd "C-<f3>") 'paf/toggle-calendar-buffer)

#+end_src

** Balance window size automatically
#+begin_src emacs-lisp
  (use-package balanced-windows
    :ensure t
    :config
    (balanced-windows-mode))
#+end_src

* Colors and Look
** Match theme color during startup as well.
#+begin_src emacs-lisp
  (set-background-color "#3f3f3f")
  (set-foreground-color "#f0dfaf")
#+end_src

** In X11 mode: mouse and window title
#+begin_src emacs-lisp
    (setq frame-title-format "emacs @ %b - %f")
    (when (display-graphic-p)
      (mouse-wheel-mode)  ;; enable wheelmouse support by default
      (set-selection-coding-system 'compound-text-with-extensions)
      ;; Let the desktop background show through
      ; (set-frame-parameter (selected-frame) 'alpha '(97 . 100))
      ; (add-to-list 'default-frame-alist '(alpha . (90 . 90)))
      )
#+end_src

** Look: buffer naming
#+begin_src emacs-lisp
(use-package uniquify
  :init
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+end_src

** Buffer Decorations
Setup the visual cues about the current editing buffer
#+begin_src emacs-lisp
  (column-number-mode t)
  (setq visible-bell t)
  (setq scroll-step 1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (setq-default transient-mark-mode t)  ;; highlight selection
#+end_src

** nyan-mode
#+begin_src emacs-lisp
(use-package nyan-mode
  :ensure t
  :bind ("C-p n" . 'nyan-mode))
#+end_src

** dynamic cursor colors
The cursor is displayed in different colors, depending on overwrite or insert mode.
#+begin_src emacs-lisp
(setq hcz-set-cursor-color-color "")
(setq hcz-set-cursor-color-buffer "")

(defun hcz-set-cursor-color-according-to-mode ()
  "change cursor color according to some minor modes."
  ;; set-cursor-color is somewhat costly, so we only call it when needed:
  (let ((color
         (if buffer-read-only "orange"
           (if overwrite-mode "red"
             "green"))))
    (unless (and
             (string= color hcz-set-cursor-color-color)
             (string= (buffer-name) hcz-set-cursor-color-buffer))
      (set-cursor-color (setq hcz-set-cursor-color-color color))
      (setq hcz-set-cursor-color-buffer (buffer-name)))))

(add-hook 'post-command-hook 'hcz-set-cursor-color-according-to-mode)
#+end_src

** theme / faces
I really like the high-contract Zenburn theme.
#+begin_src emacs-lisp
  (use-package hc-zenburn-theme
    :ensure t)

  ;; This makes some of the faces a bit more contrasted.
  ;; faces for general region highlighting zenburn is too low-key.
  (custom-set-faces
   '(highlight ((t (:background "forest green"))))
   '(region ((t (:background "forest green"))))
   ;;'(default ((t (:family "JetBrains Mono" :foundry "JB" :slant normal :weight extra-light :height 98 :width normal))))
   )
#+end_src

** Icons
This is to get all the icons we want.
Don't forget to run =all-the-icons-install-fonts= !

#+begin_src emacs-lisp
   (use-package all-the-icons
     :if (display-graphic-p)
     :ensure t
     :config
     (defface all-the-icons-hidden
       '((((background dark)) :foreground "#444444")
         (((background light)) :foreground "#444444"))
       "Face for hidden folders"
       :group 'all-the-icons-faces)
     ;; for bazel 
     (add-to-list 'all-the-icons-icon-alist
                  '("^BUILD$" all-the-icons-material "build" :face all-the-icons-blue))
     (add-to-list 'all-the-icons-icon-alist
                  '("^WORKSPACE$" all-the-icons-faicon "cube" :face all-the-icons-blue))
     (add-to-list 'all-the-icons-icon-alist
                  '("\\.bzl$" all-the-icons-material "build" :face all-the-icons-blue))
     ;; for protobufs
     (add-to-list 'all-the-icons-extension-icon-alist
                  '("proto" all-the-icons-faicon "tag" :face all-the-icons-blue))
     (add-to-list 'all-the-icons-extension-icon-alist
                  '("textpb" all-the-icons-faicon "tags" :face all-the-icons-blue))
     ;; hidden directories
     (add-to-list 'all-the-icons-dir-icon-alist
                  '("^\\." all-the-icons-material "panorama_fish_eye" :face all-the-icons-hidden))
     (add-to-list 'all-the-icons-dir-icon-alist
                  '("^\\.hg" all-the-icons-fileicon "hg" :face all-the-icons-blue))
     )
  ;;
#+end_src

Also decorate the browsing of files.
#+begin_src emacs-lisp
  ;; not installed, as it is apparently much slower than treemacs.
  (use-package all-the-icons-dired
    :if (display-graphic-p)
    :ensure t
    :hook (dired-mode . all-the-icons-dired-mode)
    :config
    (setq all-the-icons-dired-monochrome nil))
#+end_src

After reading this [[https://www.reddit.com/r/emacs/comments/aaa66z/treemacsiconsdired_treemacs_file_icons_for_your/][reddit post]], I decided to try with treemacs. alas, the icons are not transparent, so they get a white frame. My dark theme does not like it...
#+begin_src emacs-lisp :tangle no
  (use-package treemacs-icons-dired
    :ensure t
    :after treemacs dired
    :ensure t
    :config (treemacs-icons-dired-mode))
#+end_src

** Mode line
check out [[https://www.google.com/search?q=emacs+customize+modeline&sxsrf=ALiCzsZLqzMitOYNvmM9wa96Xo1VkqGLgQ%3A1671223858806&ei=MtqcY-vUMLOMlQe9v5-wAg&oq=emacs+modeline&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQARgCMgYIABAHEB4yBggAEAcQHjIGCAAQBxAeMgYIABAHEB4yBggAEAcQHjIGCAAQBxAeMgYIABAHEB4yBggAEAcQHjIGCAAQBxAeMgYIABAHEB46CggAEEcQ1gQQsAM6BwgjELACECc6CgghEMMEEAoQoAE6BQgAEKIESgQIQRgASgQIRhgAUMszWLpWYNNzaAFwAXgAgAHKAYgBsAWSAQU2LjAuMZgBAKABAcgBCMABAQ&sclient=gws-wiz-serp#fpstate=ive&vld=cid:26e96369,vid:lFrQ-PUgKHo][this video]] for a simple explanation and the [[https://occasionallycogent.com/custom_emacs_modeline/index.html][accompanying blogpost]].

My attempt is to get a modeline that shows me the following:

         1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
● [project] //p/t/file.cc     21% (126,23) UTF-8  master

|   <c>    |     <c>      |                                                                                   |
| position |   example    | description                                                                       |
|----------+--------------+-----------------------------------------------------------------------------------|
|          |              |                                                                                   |
|    1     |              | misc info from emacs (pop windows, etc.)                                          |
|    2     |              | info about emacsclient frames, remote buffers                                     |
|    3     |      ●       | dot (green: r/w non-edited; red: r/w edited; grey: r/o)                           |
|    4     |  [project]   | the project (dir in which the VCS is in)                                          |
|    5     |      //      | hint at where this is (// -> in 'src', B: -> in build, R: -> in READONLY)         |
|    6     | p/t/file.cc  | shortened file path (some known paths are shortened) with fill file path on hover |
|    7     |             | major mode (hover to find out the minor ones)                                     |
|    8     |              | <spacer here>                                                                     |
|    9     | 21% (126,23) | position in file (mode-line-position)                                             |
|    10    |    UTF-8     | file encoding                                                                     |
|    11    |             | VCS, when available                                                               |
|    12    |    master    | branch (git), bookmark (hg)                                                       |

Envisioned faces:
paf-line-read-only :: for the read-only file dot
paf-line-read-write :: for the read-write and non-edited file dot
paf-line-edited :: for read-write and edited mode (needs save!)
paf-line-project :: to render the project part of the path
paf-line-location-hint :: to render the location in the client
paf-line-file-path :: for the path part of the file
paf-line-file-name :: for the basename of the file
paf-line-major-mode : for the major mode part
paf-line-file-encoding :: for the file encoding...
paf-line-vcs-type :: for the VCS, in case it's text
paf-line-branch-name :: for the branch/bookmark of the VCS

#+begin_src emacs-lisp :tangle no
  (defun custom-modeline-file-state ()
      ((let* (
              (config-alist
               '(("*" all-the-icons-faicon-family all-the-icons-faicon "chain-broken" :height 1.2 :v-adjust -0.0)
                 ("-" all-the-icons-faicon-family all-the-icons-faicon "link" :height 1.2 :v-adjust -0.0)
                 ("%" all-the-icons-octicon-family all-the-icons-octicon "lock" :height 1.2 :v-adjust 0.1)))
              (result (cdr (assoc (format-mode-line "%*") config-alist))))
         (propertize (apply (cadr result) (cddr result))
                     'face `(:family ,(funcall (car result)))))))

    (defun custom-modeline-mode-icon ()
      (format " %s"
              (propertize icon
                          'help-echo (format "Major-mode: `%s`" major-mode)
                          'face `(:height 1.2 :family ,(all-the-icons-icon-family-for-buffer)))))

  (defun custom-modeline-region-info ()
    (when mark-active
      (let ((words (count-lines (region-beginning) (region-end)))
            (chars (count-words (region-end) (region-beginning))))
        (concat
         (propertize (format "   %s" (all-the-icons-octicon "pencil") words chars)
                     'face `(:family ,(all-the-icons-octicon-family))
                     'display '(raise -0.0))
         (propertize (format " (%s, %s)" words chars)
                     'face `(:height 0.9))))))

  (defun -custom-modeline-github-vc ()
    (let ((branch (mapconcat 'concat (cdr (split-string vc-mode "[:-]")) "-")))
      (concat
       (propertize (format " %s" (all-the-icons-alltheicon "git")) 'face `(:height 1.2) 'display '(raise -0.1))
       " Â· "
       (propertize (format "%s" (all-the-icons-octicon "git-branch"))
                   'face `(:height 1.3 :family ,(all-the-icons-octicon-family))
                   'display '(raise -0.1))
       (propertize (format " %s" branch) 'face `(:height 0.9)))))

  (defun -custom-modeline-svn-vc ()
    (let ((revision (cadr (split-string vc-mode "-"))))
      (concat
       (propertize (format " %s" (all-the-icons-faicon "cloud")) 'face `(:height 1.2) 'display '(raise -0.1))
       (propertize (format " Â· %s" revision) 'face `(:height 0.9)))))

  (defun custom-modeline-icon-vc ()
    (when vc-mode
      (cond
        ((string-match "Git[:-]" vc-mode) (-custom-modeline-github-vc))
        ((string-match "SVN-" vc-mode) (-custom-modeline-svn-vc))
        (t (format "%s" vc-mode)))))


  (defun custom-modeline-flycheck-status ()
    (let* ((text (pcase flycheck-last-status-change
                   (`finished (if flycheck-current-errors
                                  (let ((count (let-alist (flycheck-count-errors flycheck-current-errors)
                                                 (+ (or .warning 0) (or .error 0)))))
                                    (format "𐄂 %s Issue%s" count (unless (eq 1 count) "s")))
                                "✔ No Issues"))
                   (`running     "↻ Running")
                   (`no-checker  "⚠ No Checker")
                   (`not-checked "𐄂 Disabled")
                   (`errored     "⚠ Error")
                   (`interrupted "⏱ Interrupted")
                   (`suspicious  ""))))
      (propertize text
                  'help-echo "Show Flycheck Errors"
                  'mouse-face '(:box 1)
                  'local-map (make-mode-line-mouse-map
                              'mouse-1 (lambda () (interactive) (flycheck-list-errors))))))


  (setq mode-line-format '("%e" (:eval
                                 (concat
                                  (custom-modeline-file-state)
                                  (custom-modeline-mode-icon)
                                  (custom-modeline-icon-vc)
                                  (custom-modeline-region-info)
                                  (custom-modeline-flycheck-status)))))
#+end_src

Also discovered SmartModeLine tht gets me quite a bit there.
Note that you should *beware escaping hell!!!* What you see on the web page is not exactly what is in the file!!!
There are many traps in this module, as it does some magic while you're not watching that totally gets in the way when you first try to play with this.
The web-page examples *cannot be cut/pasted* as they are not escaped properly.

#+begin_src emacs-lisp
  (defun paf/sml-shorten-filepath-setup ()
    (setq sml/replacer-regexp-list '())
    ;; (add-to-list 'sml/replacer-regexp-list '("^/usr/local/google/home/fleury/" "H/") t) ;; 🡇
    (add-to-list 'sml/replacer-regexp-list
                 '("^~/OrgFiles\\(-priv\\|-prof\\)?" "[Org]") t)
    ;; This for most code editing tasks
    (add-to-list 'sml/replacer-regexp-list
                 '("^~/Projects/\\([^/]*\\)/\\(\\(fig\\|git.?\\|exp\\)-[^/]*\\)" "[🡇\\2]") t)
    (add-to-list 'sml/replacer-regexp-list
                 '("^/google/src/cloud/fleury/\\([^/]+\\)" "[☁\\1]") t)
    ;; path simplifications
    (add-to-list 'sml/replacer-regexp-list '("/google3/" " //") t)
    (add-to-list 'sml/replacer-regexp-list '("/nlp/generation/" "/n/g/") t)

    (add-to-list 'sml/prefix-regexp "\\[[^]]*\\]")
  )

  (use-package smart-mode-line
    :ensure t
    :config
    (setq sml/theme 'respectful)
    (paf/sml-shorten-filepath-setup)
    (setq sml/name-width 60)
    (setq sml/no-confirm-load-theme t)
    (setq sml/use-projectile-p 'after-prefixes)
    (sml/setup))

  (use-package rich-minority
    :ensure t
    :config
    ;(setq rm-whitelist "^ Projectile.*$") ;; read the doc for what to set here!!
    (setq rm-whitelist "^none$") ;; this will match no minor mode
    )
#+end_src

* Key Mappings
** which-key
This will show the list of the possible completion keys during a longer key sequence.
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :custom (which-key-idle-delay 2.0)
    :config (which-key-mode t))
#+end_src

** alternate key mappings
Letting one enter chars that are otherwise difficult in e.g. the minibuffer.
#+begin_src emacs-lisp
(global-set-key (kbd "C-m") 'newline-and-indent)
(global-set-key (kbd "C-j") 'newline)
(global-set-key [delete] 'delete-char)
(global-set-key [kp-delete] 'delete-char)
#+end_src

** home and end
#+begin_src emacs-lisp
  (global-set-key (kbd "<home>") 'beginning-of-line)
  (global-set-key (kbd "<end>") 'end-of-line)
#+end_src

** Macros
#+begin_src emacs-lisp
(global-set-key [f3] 'start-kbd-macro)
(global-set-key [f4] 'end-kbd-macro)
(global-set-key [f5] 'call-last-kbd-macro)
#+end_src

** Text size
Increase/decrease text size
#+begin_src emacs-lisp
(define-key global-map (kbd "C-+") 'text-scale-increase)
(define-key global-map (kbd "C--") 'text-scale-decrease)
#+end_src

** multiple regions
#+begin_src emacs-lisp
(global-set-key (kbd "C-M-i") 'iedit-mode)
#+end_src

** Moving around buffers
#+begin_src emacs-lisp
(global-set-key (kbd "C-c <C-left>")  'windmove-left)
(global-set-key (kbd "C-c <C-right>") 'windmove-right)
(global-set-key (kbd "C-c <C-up>")    'windmove-up)
(global-set-key (kbd "C-c <C-down>")  'windmove-down)
(global-set-key (kbd "C-c C-g") 'goto-line)
#+end_src

** Moving tabs
#+begin_src emacs-lisp
  ;; These are PgUp (<prior>) and PgDown (<next>)
  (global-set-key (kbd "C-<prior>")  'tab-bar-switch-to-prev-tab)
  (global-set-key (kbd "C-<next>")  'tab-bar-switch-to-next-tab)
#+end_src

** multiple-cursors
Configure the shortcuts for multiple cursors
#+begin_src emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-S-c C-S-c" . 'mc/edit-lines)
         ("C->" . 'mc/mark-next-like-this)
         ("C-<" . 'mc/mark-previous-like-this)
         ("C-c C->" . 'mc/mark-all-like-this)))
#+end_src

** ace-jump-mode
Let's one jump around text
#+begin_src emacs-lisp
(use-package ace-jump-mode
  :ensure t
  :bind (("C-c C-SPC" . 'ace-jump-mode)
         ("C-c C-DEL" . 'ace-jump-mode-pop-mark)))
#+end_src

#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :bind (("C-x w w" . 'ace-window)))
#+end_src

** Hydra
#+begin_src emacs-lisp
  (use-package hydra
    :ensure t)
#+end_src

** Accents
This will enable a popup to add diacritics to a letter. See [[https://github.com/elias94/accent][accent]] on github.
#+begin_src emacs-lisp
  (use-package accent
    :ensure t)

  (global-set-key (kbd "C-x C-'") 'accent-menu)
#+end_src

* Editing Style
** No tabs, ever. No trailing spaces either.
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq require-final-newline t)
(setq next-line-add-newlines nil)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

** Mark the 80 cols boundary
#+begin_src emacs-lisp
  (use-package column-enforce-mode
    :ensure t
    :config
    (setq column-enforce-column 80)
    :bind ("C-c m" . 'column-enforce-mode))
  ;; column-enforce-face
#+end_src

** Better kill ring
Seen demonstrated by [[https://www.youtube.com/watch?v=LFXA089Tx38][Uncle Dave]]
#+begin_src emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+end_src

* Cool Packages
** annotate-mode
The file-annotations are store externally. Seems to fail with =args-out-of-range= and then Emacs is confused. (filed issue for this)

Also, it seems to interfere with colorful modes like =magit= or =org-agenda-mode= so that I went with a whitelist instead of the wish of a blacklist of modes.

#+begin_src emacs-lisp
(use-package annotate
  :ensure t
  :bind ("C-c C-A" . 'annotate-annotate)  ;; for ledger-mode, as 'C-c C-a' is taken there.
  :config
  ;;(add-hook 'org-mode 'annotate-mode)
  (add-hook 'csv-mode 'annotate-mode)
  (add-hook 'c-mode 'annotate-mode)
  (add-hook 'c++-mode 'annotate-mode)
  (add-hook 'sh-mode 'annotate-mode)
  (add-hook 'ledger-mode 'annotate-mode)
;;;  (define-globalized-minor-mode global-annotate-mode annotate-mode
;;;    (lambda () (annotate-mode 1)))
;;;  (global-annotate-mode 1)
  )
#+end_src

** web-mode
web-mode with config for Polymer editing
#+begin_src emacs-lisp
(use-package web-mode
  :ensure t
  :mode "\\.html\\'"
  :config
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2))
#+end_src

** typescript-mode
#+begin_src emacs-lisp
  (use-package typescript-mode
    :ensure t
    :mode "\\.ts\\'"
    ;; :config
    ;; (setq typescript-indent-level 2)
    )
#+end_src

** csv-mode
mode to edit CSV files.
#+begin_src emacs-lisp
  (use-package csv-mode
    :ensure t
    :mode "\\.csv\\'")
#+end_src

** protobuf-mode
Mode for Google protocol buffer mode
#+begin_src emacs-lisp
  (use-package protobuf-mode
    :ensure t
    :mode "\\.proto\\'")
#+end_src

** rainbow-mode
Colorize color names and hexadecimal codes in the correct color.
#+begin_src emacs-lisp
(use-package rainbow-mode
  :ensure t)
#+end_src

** taskjuggler-mode (tj3-mode)
#+begin_src emacs-lisp
  (use-package ox-taskjuggler
    :load-path (lambda () (expand-file-name paf-lisp-directory)))

  (use-package tj3-mode
    :ensure t
    :after ox-taskjuggler
    :config
    (require 'ox-taskjuggler)
    (custom-set-variables
     '(org-taskjuggler-process-command "/usr/bin/tj3 --silent --no-color --output-dir %o %f")
     '(org-taskjuggler-project-tag "PRJ")))
#+end_src

#+begin_src bash :tangle bash/install_deps.sh
  # Install TaskJuggler
  if [[ "$(uname -m)" == "x86_64" ]]; then
    if [[ "$(which tj3)" == "" ]]; then
      case "$(uname)" in
        Darwin)  brew install ruby ; sudo gem install taskjuggler ;;
        ,*)       install_pkg tj3 ;;
      esac
    fi
  fi
#+end_src

** writeroom-mode
#+begin_src emacs-lisp
(use-package writeroom-mode
  :ensure t
  :init
  (global-set-key (kbd "C-p W") 'writeroom-mode))
#+end_src

** wgrep-mode
#+begin_src emacs-lisp
(use-package wgrep
  :ensure t)
#+end_src

** [[https://github.com/ledger/ledger-mode][ledger-mode]]
*** Cleanup ledger file
#+begin_src emacs-lisp
(defun single-lines-only ()
  "replace multiple blank lines with a single one"
  (interactive)
  (goto-char (point-min))
  (while (re-search-forward "\\(^\\s-*$\\)\n" nil t)
    (replace-match "\n")
    (forward-char 1)))

(defun paf/cleanup-ledger-buffer ()
  "Cleanup the ledger file"
  (interactive)
  (delete-trailing-whitespace)
  (single-lines-only)
  (ledger-mode-clean-buffer)
  (ledger-sort-buffer))
#+end_src

*** Compute formatted sum of region
It actually computes the entire arithmetic expression that is selected, and replaces it with the numerical result.
#+begin_src emacs-lisp
  (defun apply-function-to-region (fn)
    (interactive "XFunction to apply to region: ")
    (save-excursion
      (let* ((beg (region-beginning))
             (end (region-end))
             (had-region (use-region-p))
             (resulting-text
              (funcall
               fn
               (buffer-substring-no-properties beg end)))
             (new-end (+ beg (length resulting-text))))
        (kill-region beg end)
        (insert resulting-text)
        ;; set the active region again if it was set originally.
        (if had-region
            (progn
              (goto-char beg)
              (push-mark new-end)
              (setq mark-active t))))))

  (defun paf/sum-amount (expression)
    "Computes the sum from the arith expression given as argument."
    (format "%.2f" (string-to-number (calc-eval expression))))

  (defun paf/sum-amount-of-region ()
    "Takes the region as an arithmetic expr, and replaces it with its sum."
    (interactive)
    (if (use-region-p)
        (progn
          (apply-function-to-region 'paf/sum-amount)
          (goto-char (region-end)))))

  (global-set-key (kbd "C-p S") 'paf/sum-amount-of-region)
#+end_src

*** Setup
#+begin_src emacs-lisp
  ;; To get ob-ledger
  (use-package org-contrib
    :ensure t)

  (use-package ledger-mode
    :ensure t
    :bind ("<f6>" . 'paf/cleanup-ledger-buffer)
    :config
    (setq ledger-reconcile-default-commodity "CHF")
    :init
    (add-hook 'ledger-mode-hook
              (lambda ()
                (setq-local tab-always-indent 'complete)
                (setq-local completion-cycle-threshold t)
                (setq-local ledger-complete-in-steps t))))
#+end_src

** [[http://www.gnu.org/software/hyperbole/][hyperbole]]
I found some gems that explain a bit better what hyperbole is trying to solve. See John Wiegley's [[https://www.reddit.com/r/emacs/comments/7daneo/announce_gnu_hyperbole_7_aka_the_git_ready_for/dpx5sxw/][Using hyperbole: a motivation]]
Once more it shows that the most powerful things are not always the most visible nor the easiest to explain.

*NOTE* assigns =hui-search-web= to =C-c C-/= to not clobber the later used =C-c /= from OrgMode (org-mode sparse trees). This works because hyperbole will first check if the function is already bound to some key before binding it to the coded default.
#+begin_src emacs-lisp
  (use-package hyperbole
    :ensure t
    :bind
    ("C-c C-/" . hui-search-web)  ;; bind before calling require
    :custom-face
    (hbut       ((t (:foreground "green yellow"))))
    (hbut-flash ((t (:foreground "dark gray" :background "green yellow"))))
    :config
    (setq hbmap:dir-user org-directory)
    (setq hbmap:filename "personal-buttons.hypb")
    (load-file (expand-file-name "hyperbole-systems.el" paf-lisp-directory)))

    (require 'hyperbole)
#+end_src

** [[https://github.com/fourier/ztree#ztree][ztree]]
A tree-view navigation of files, with diff tool for directories.
#+begin_src emacs-lisp :tangle no
  (use-package ztree
    :ensure t)
#+end_src

** graphviz mode
#+begin_src emacs-lisp
  (use-package graphviz-dot-mode
    :ensure t)
#+end_src

** Google This!
This package enables to get Google search results within Emacs itself. The default map is bound to =C-c /= so search for thing at point is =C-c / g=.

#+begin_src emacs-lisp
  (use-package google-this
    :ensure t
    :config
    (setq google-this-browse-url-function 'eww-browse-url)
    (google-this-mode 1))
#+end_src

** GnuPlot
#+begin_src emacs-lisp
  (use-package gnuplot
    :ensure t)
#+end_src

#+begin_src bash :tangle bash/install_deps.sh
install_pkg gnuplot
#+end_src

* Coding
** VCS
*** magit
Add the powerful Magit
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :defer
    :bind ("C-x g" . 'magit-status))
  (use-package magit-todos
    :ensure t
    :defer)
#+end_src

** Projectile
Start using projectile. It has the documentation [[https://docs.projectile.mx/en/latest/][here]].
#+begin_src emacs-lisp
  (defun paf/projectile-relative-buf-name ()
    (ignore-errors
      (rename-buffer
       (file-relative-name buffer-file-name (projectile-project-root)))))

  (use-package projectile
    :ensure t
    :config
    (projectile-mode 1)
    (setq projectile-sort-order 'modification-time)
    (define-key projectile-mode-map (kbd "C-S-p") 'projectile-command-map)
    (add-hook 'find-file-hook 'paf/projectile-relative-buf-name)
    ;; overwrite this function, see https://github.com/bbatsov/projectile/issues/1816
    (defun projectile-expand-file-name-wildcard (name-pattern dir)
      "overridden."
      (let ((expanded (expand-file-name name-pattern dir)))
        (or (if (string-match-p "[[*?]" name-pattern)
                (car
                 (ignore-errors
                   (file-expand-wildcards expanded))))
            expanded)))
    )

  (use-package persp-projectile
    :ensure t
    :after (perspective projectile)
    :requires persp-projectile)
#+end_src

Also make sure we do have the faster [[https://github.com/ggreer/the_silver_searcher#the-silver-searcher][silver searcher]] version.  This may need you to install the corresponding tool for this, with the following snippet:
#+begin_src bash :tangle bash/install_deps.sh
if [[ "$(uname)" == "Darwin" ]]; then
  install_pkg -x ag the_silver_searcher
else
  install_pkg -x ag silversearcher-ag
fi
#+end_src

Search the entire project with =C-c p s s= for a regexp. This let's you turn the matching results into an editable buffer using =C-c C-e=. Other keys are listed [[https://github.com/syohex/emacs-helm-ag#keymap][here]].

#+begin_src emacs-lisp
  (use-package ag
    :ensure t)
#+end_src

** Code completion
I went with the suggestion found on this [[https://www.juniordeveloperdiaries.com/emacs-intro/][Emacs intro]] guide.

Both =eglot= and =lsp-mode= would need the =company= mode.
#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :bind (("C-." . company-complete))
    :custom
    (company-idle-delay 0) ;; I always want completion, give it to me asap
    (company-dabbrev-downcase nil "Don't downcase returned candidates.")
    (company-show-numbers t "Numbers are helpful.")
    (company-tooltip-limit 10 "The more the merrier.")
    :config
    (global-company-mode) ;; We want completion everywhere

    ;; use numbers 0-9 to select company completion candidates
    (let ((map company-active-map))
      (mapc (lambda (x) (define-key map (format "%d" x)
                          `(lambda () (interactive) (company-complete-number ,x))))
            (number-sequence 0 9))))
#+end_src

*** lsp-mode
#+begin_src emacs-lisp :tangle no
  ;; Flycheck is the newer version of flymake and is needed to make lsp-mode not freak out.
  (use-package flycheck
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'flycheck-mode) ;; always lint my code
    (add-hook 'after-init-hook #'global-flycheck-mode))

  ;; Package for interacting with language servers
  (use-package lsp-mode
    :ensure t
    :commands lsp
    :config
    (setq lsp-prefer-flymake nil ;; Flymake is outdated
          lsp-headerline-breadcrumb-mode nil)) ;; I don't like the symbols on the header a-la-vscode, remove this if you like them.
#+end_src

*** eglot
#+begin_src emacs-lisp
  (use-package eglot
    :ensure t
    :bind (:map eglot-mode-map
                ("C-c <tab>" . company-complete) ; initiate the completion manually
                ("C-c e f n" . flymake-goto-next-error)
                ("C-c e f p" . flymake-goto-prev-error)
                ("C-c e r"   . eglot-rename)))
#+end_src

** header/implementation toggle
Switch from header to implementation file quickly.
#+begin_src emacs-lisp
  (add-hook 'c-mode-common-hook
            (lambda ()
              (progn
                (local-set-key  (kbd "C-c o") 'ff-find-other-file)
                (local-set-key  (kbd "C-c f") 'find-file-at-point))))
#+end_src

** no indentation of namespaces in C++
Essentially, use the Google C++ style formatting.
#+begin_src emacs-lisp
  (use-package google-c-style
    :ensure t
    :config
    (add-hook 'c-mode-common-hook 'google-set-c-style)
    (add-hook 'c-mode-common-hook 'google-make-newline-indent))

  ;;(use-package flymake-google-cpplint
  ;;  :ensure t)
#+end_src

** ripgrep
This enables searching recursively in projects.
#+begin_src bash :tangle bash/install_deps.sh
install_pkg -x rg ripgrep
#+end_src

#+begin_src emacs-lisp
  (use-package rg
    :ensure t
    :config
    (rg-enable-menu))
  (use-package ripgrep
    :ensure t)
  (use-package projectile-ripgrep
    :ensure t
    :requires (ripgrep projectile))
#+end_src

** Deduplicate and sort
Help cleanup the includes and using lists.
[[http://www.emacswiki.org/emacs/DuplicateLines][found here]]
#+begin_src emacs-lisp
(defun uniquify-region-lines (beg end)
  "Remove duplicate adjacent lines in region."
  (interactive "*r")
  (save-excursion
    (goto-char beg)
    (while (re-search-forward "^\\(.*\n\\)\\1+" end t)
      (replace-match "\\1"))))

(defun paf/sort-and-uniquify-region ()
  "Remove duplicates and sort lines in region."
  (interactive)
  (sort-lines nil (region-beginning) (region-end))
  (uniquify-region-lines (region-beginning) (region-end)))
#+end_src

Simplify cleanup of =#include= / =typedef= / =using= blocks.
#+begin_src emacs-lisp
(global-set-key (kbd "C-p s") 'paf/sort-and-uniquify-region)
#+end_src

** diffing
[[https://github.com/justbur/emacs-vdiff][vdiff]] let's one compare buffers or files.
#+begin_src emacs-lisp
  (use-package vdiff
    :ensure t
    :config
    ; This binds commands under the prefix when vdiff is active.
    (define-key vdiff-mode-map (kbd "C-c") vdiff-mode-prefix-map))
#+end_src

** yasnippet / abbrev / auto-yasnippet
The key for yasnippet expansion is for me =S-TAB= to no clash with regular code indentation.
The snippets are mode-dependent. See the [[http://joaotavora.github.io/yasnippet/][full documentation]].

Some of the keys are listed here. The prefix is =C-c &=

| Command                | key after C-c & |
|------------------------+-----------------|
| yas-new-snippet        | C-n             |
| yas-insert-snippet     | C-s             |
| yas-visit-snippet-file | C-v             |

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (setq yas-snippet-dirs
          (list (expand-file-name "Yasnippets" emacs-config-directory)))
    (yas-global-mode 1))

  (use-package auto-yasnippet
    :ensure t
    :after yasnippet
    :config
    (setq aya-case-fold t)
    (bind-key "C-p C-s c" 'aya-create)
    (bind-key "C-p C-s e" 'aya-expand))
#+end_src

For the abbrev mode, that I use only for correcting typos, I set it up in emacs dir.
To add an abbrev after one has typed something wrong, just use =C-x a i g= (add inverse global) to add the actual text that should have been written.

#+begin_src emacs-lisp
  (use-package abbrev
    :config
    (setq abbrev-file-name (expand-file-name "abbrev_defs" emacs-config-directory))
    (setq save-abbrevs 'silent)
    (setq-default abbrev-mode t)
    (if (file-exists-p abbrev-file-name)
        (quietly-read-abbrev-file)))
#+end_src

** Selective display
Will fold all text indented more than the position of the cursor at the time the keys are pressed.
#+begin_src emacs-lisp
  (defun set-selective-display-dlw (&optional level)
    "Fold text indented more than the cursor.
     If level is set, set the indent level to level.
     0 displays the entire buffer."
    (interactive "P")
    (let* ((base-column (current-column))
           (from-column (if (= base-column 0) 0 (1+ base-column))))
      (set-selective-display (or level from-column))))

  (global-set-key (kbd "C-x $") 'set-selective-display-dlw)
#+end_src

** Info in the gutter
*** Line numbers
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (setq-default display-line-number-width 3)
  (global-set-key (kbd "C-p l") 'display-line-numbers-mode)
#+end_src

*** git informations
#+begin_src emacs-lisp :tangle no
(use-package git-gutter-fringe+
  :ensure t
  :defer
  :if (display-graphic-p)
  :bind ("C-p g" . 'git-gutter+-mode))
#+end_src

** Speedup VCS
Regexp matching directory names that are not under VC's control. The default regexp prevents fruitless and time-consuming attempts to determine the VC status in directories in which filenames are interpreted as hostnames.
#+begin_src emacs-lisp
(defvar locate-dominating-stop-dir-regexp
  "\\`\\(?:[\\/][\\/][^\\/]+\\|/\\(?:net\\|afs\\|\\.\\.\\.\\)/\\)\\'")
#+end_src

** Dealing with numbers
Simple way to increase/decrease a number in code.
#+begin_src emacs-lisp
  (use-package shift-number
    :ensure t
    :bind (("M-+" . shift-number-up)
           ("M-_" . shift-number-down)))
#+end_src

** Debugging
*** GDB with many windows
**** Make it so that the source frame placement is forced only when using gdb.
:LOGBOOK:
- State "TODO"       from              [2022-02-01 Tue 10:05]
:END:
See =gnu.org=  [[https://www.gnu.org/software/emacs/manual/html_node/emacs/GDB-User-Interface-Layout.html][documentation of this feature]]

#+begin_src emacs-lisp
  (setq gdb-many-windows t)
  (setq gdb-max-source-window-count 1)
  ;; (setq gdb-show-main t)
  (setq gdb-restore-window-configuration-after-quit t)

  ;; (setq gdb-default-window-configuration-file "gdb.layout")
#+end_src

This should display the source code always in the same window when debugging.
Found on [[https://stackoverflow.com/questions/39762833/emacsgdb-customization-how-to-display-source-buffer-in-one-window][Stack Overflow]].

#+begin_src emacs-lisp :tangle no
  (add-to-list 'display-buffer-alist
               (cons 'gdb-source-code-buffer-p
                     (cons 'display-buffer-use-some-window nil)))

  (defun gdb-source-code-buffer-p (bufName action)
    "Return whether BUFNAME is a source code buffer and gdb is running."
    (let ((buf (get-buffer bufName)))
      (and buf
            (boundp 'gud-minor-mode)
            (eq gud-minor-mode 'gdbmi)
            (with-current-buffer buf
              (derived-mode-p buf 'c++-mode 'c-mode)))))
#+end_src

**** Highlight current line
Solution see here: https://weilin2015.wordpress.com/2020/11/16/highlight-gdb-breakpoint-line-and-current-line/

#+begin_src emacs-lisp
  ;; highlight current line while debugging
  (defface xwl-gdb-current-line-face
    '((((class color))
       (:background "dark green")))
    "")

  (setq xwl-gdb-current-line-overlay nil)
  (defun xwl-gdb-highlight-current-line ()
    (when gud-overlay-arrow-position
      (with-current-buffer (marker-buffer gud-overlay-arrow-position)
        (when xwl-gdb-current-line-overlay
          (delete-overlay xwl-gdb-current-line-overlay))
        (setq xwl-gdb-current-line-overlay (make-overlay gud-overlay-arrow-position (line-end-position)))
        (overlay-put xwl-gdb-current-line-overlay 'face 'xwl-gdb-current-line-face))))

  (defun xwl-gdb-unhighlight-current-line ()
   (delete-overlay xwl-gdb-current-line-overlay))


  ;; Highlight break points
  (defface xwl-gdb-breakpoint-line-face
    '((((class color))
       (:background "IndianRed4")))
    "")

  (defun xwl-gdb-highlight-breakpoint-line (enabled bptno &optional line)
    (let* ((bp-line (or line (line-number-at-pos)))
           (points (gdb-line-posns bp-line))
           (bp-overlay (make-overlay (car points) (cdr points))))
      (overlay-put bp-overlay 'face 'xwl-gdb-breakpoint-line-face)))

  (defun xwl-gdb-unhighlight-breakpoint-lines (start end &optional remove-margin)
    (dolist (overlay (overlays-in start end))
      (when (eq (overlay-get overlay 'face) 'xwl-gdb-breakpoint-line-face)
        (delete-overlay overlay))))


  (with-eval-after-load 'gdb-mi
    (advice-add 'gdb-frame-handler :after 'xwl-gdb-highlight-current-line)
    (advice-add 'gdb-reset :after 'xwl-gdb-unhighlight-current-line)
    (advice-add 'gdb-put-breakpoint-icon :after 'xwl-gdb-highlight-breakpoint-line)
    (advice-add 'gdb-remove-breakpoint-icons :after 'xwl-gdb-unhighlight-breakpoint-lines)
    )
#+end_src

**** TODO Instrument / advice gdb for restoring layout
:LOGBOOK:
- State "TODO"       from              [2022-02-01 Tue 01:01]
:END:
Information taken here: https://stackoverflow.com/questions/3860028/customizing-emacs-gdb/41326527

#+begin_src emacs-lisp :tangle no
  (setq gdb-many-windows nil)

  (defun set-gdb-layout(&optional c-buffer)
    (if (not c-buffer)
        (setq c-buffer (window-buffer (selected-window)))) ;; save current buffer

    ;; from http://stackoverflow.com/q/39762833/846686
    (set-window-dedicated-p (selected-window) nil) ;; unset dedicate state if needed
    (switch-to-buffer gud-comint-buffer)
    (delete-other-windows) ;; clean all

    (let* (
           (w-source (selected-window)) ;; left top
           (w-gdb (split-window w-source nil 'right)) ;; right bottom
           (w-locals (split-window w-gdb nil 'above)) ;; right middle bottom
           (w-stack (split-window w-locals nil 'above)) ;; right middle top
           (w-breakpoints (split-window w-stack nil 'above)) ;; right top
           (w-io (split-window w-source (floor(* 0.9 (window-body-height)))
                               'below)) ;; left bottom
           )
      (set-window-buffer w-io (gdb-get-buffer-create 'gdb-inferior-io))
      (set-window-dedicated-p w-io t)
      (set-window-buffer w-breakpoints (gdb-get-buffer-create 'gdb-breakpoints-buffer))
      (set-window-dedicated-p w-breakpoints t)
      (set-window-buffer w-locals (gdb-get-buffer-create 'gdb-locals-buffer))
      (set-window-dedicated-p w-locals t)
      (set-window-buffer w-stack (gdb-get-buffer-create 'gdb-stack-buffer))
      (set-window-dedicated-p w-stack t)

      (set-window-buffer w-gdb gud-comint-buffer)
      (set-window-dedicated-p w-gdb t)

      (select-window w-source)
      (set-window-buffer w-source c-buffer)
      ))

  (defvar global-config-editing nil "Stores the window configuration before gdb changes it.")

  (defadvice gdb (around args activate)
    "Change the way to gdb works."
    (setq global-config-editing (current-window-configuration)) ;; to restore: (set-window-configuration c-editing)
    ;;(setq global-toolbar-state tool-bar-mode)
    (let (
          (c-buffer (window-buffer (selected-window))) ;; save current buffer
          )
      ad-do-it
      (tool-bar-mode 1)
      (set-gdb-layout c-buffer))
    )

  (defadvice gdb-reset (around args activate)
    "Change the way to gdb exit."
    ad-do-it
    (tool-bar-mode -1) ;;global-toolbar-state)
    (set-window-configuration global-config-editing))
#+end_src

**** Cheatsheet

Here is my cheatsheet for the keyboard commands:

All prefixed with =C-x C-a=

|------------+----------------------+---------|
| Domain     | Command              | C-<key> |
| <l>        | <l>                  |   <c>   |
|------------+----------------------+---------|
| Breakpoint | set                  |    b    |
|            | temporary            |    t    |
|            | delete               |    d    |
|------------+----------------------+---------|
| Execute    | Next                 |    n    |
|            | Step Into            |    s    |
|            | Return / Finish      |    f    |
|            | Continue (run)       |    r    |
|------------+----------------------+---------|
| Stack      | Up                   |    <    |
|            | Down                 |    >    |
|------------+----------------------+---------|
| Execute    | Until current line   |    u    |
| (rarer)    | Single instruction   |    i    |
|            | Jump to current line |    j    |
|------------+----------------------+---------|
*** LLDB
This seems to be the more modern way.
Setup info found here: https://emacs-lsp.github.io/dap-mode/page/configuration/
#+begin_src emacs-lisp :tangle no
  (use-package dap-mode
    :ensure t
    :config
    (dap-mode 1)
    (dap-tooltip-mode 1)
    (dap-auto-configure-mode 1)
    (dap-ui-controls-mode 1)
    (setq dap-auto-configure-features '(sessions locals breakpoints expressions repl controls tooltip))
    (add-hook 'dap-stopped-hook
              (lambda (arg) (call-interactively #'dap-hydra)))
    (require 'dap-gdb-lldb)
    (dap-gdb-lldb-setup t))
#+end_src

** vterm
#+begin_src emacs-lisp
  (use-package vterm
    :unless (paf/macosx-p)
    :ensure t
    :init
    (setq vterm-always-compile-module t)
    :bind
    (:map vterm-mode-map
          ("C-c q" . vterm-copy-mode)
          ("<C-backspace>" . (lambda () (interactive) (vterm-send-key (kbd "C-w"))))
          ("C-q" . vterm-send-next-key))
    (:map vterm-copy-mode-map
          ("C-c q" . vterm-copy-mode-done))
    :config
    (setq vterm-module-cmake-args "-DUSE_SYSTEM_LIBVTERM=no")
    (setq vterm-tramp-shells '(("docker" "sh") ("ssh" "'bash'"))))

  (use-package vterm-toggle
    :ensure t
    :unless (paf/macosx-p)
    :after vterm
    :bind ("C-c t" . 'vterm-toggle))
#+end_src

#+begin_src bash :tangle bash/install_deps.sh
  # Needed to compile vterm first time
  if [[ "$(uname -o)" == "Android" ]]; then
    install_pkg -x libtool libtool
  else
    install_pkg -x libtool libtool-bin
  fi
  install_pkg -x cmake cmake
  install_pkg -x perl perl

  # Also amend the bash config
  cat >> ${HOME}/.bashrc <<EOF
  # Setup Emacs's VTerm communication
  if [[ "\${INSIDE_EMACS}" =~ ^vterm ]] \\
      && [[ -n "\${EMACS_VTERM_PATH}" ]] \\
      && [[ -f "\${EMACS_VTERM_PATH}/etc/emacs-vterm-bash.sh" ]]; then
          source "\${EMACS_VTERM_PATH}/etc/emacs-vterm-bash.sh"
  fi
  EOF
#+end_src

** bazel
Adding support for Bazel
#+begin_src emacs-lisp
  (use-package bazel
    :ensure t)
#+end_src

** Hiding zones
This helps showing / hiding zones given a regexp.

The isearch+ is weird when interacting with it during incremental search.
#+begin_src emacs-lisp :tangle no
  (use-package zones
    :ensure t)

  (use-package isearch+
    :load-path (lambda () (expand-file-name paf-lisp-directory)))

  ;;(use-package isearch-prop
  ;;  :load-path (lambda () (expand-file-name paf-lisp-directory)))
#+end_src

** PlatformIO
Add the few commands to help with selecting boards etc.
See mode documentation in the [[https://github.com/ZachMassia/platformio-mode][PlatformIO Mode github page]]
#+begin_src emacs-lisp
  (use-package platformio-mode
    :ensure t)
#+end_src

** ediff
Setup ediff to not open a tiny separate frame for control, and make the windows be side-by-side in the main emacs frame.
Taken from Prot's video: https://youtu.be/pSvsAutseO0?si=3eXYVh9rKIUdSsuj&t=874
#+begin_src emacs-lisp
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

** Vertical indent bars
Displays vertical bars to show indentation visually.

#+begin_src emacs-lisp
  (use-package indent-bars
    :load-path (lambda () (expand-file-name "indent-bars" paf-modules-directory))
    :hook ((python-mode yaml-mode prog-mode) . indent-bars-mode))
#+end_src

* OrgMode
Load all my org stuff, but first org-mode itself.
** Init
If variable =org-directory= is not set yet, map it to my home's files. You may set this in the =~/.emacs= to another value, e.g. =(setq org-directory "/ssh:fleury@machine.site.com:OrgFiles")=

*** NEXT This does not seem to work, check out doc about [[https://stackoverflow.com/questions/3806423/how-can-i-get-a-variables-initial-value-in-elisp][defcustom]]
:LOGBOOK:
- State "NEXT"       from              [2019-06-24 Mon 10:10]
:END:

*** Set up org itself
#+begin_src emacs-lisp
  (if (not (boundp 'org-directory))
      (setq org-directory "~/OrgFiles"))

  (use-package org
    :ensure nil
    :config
    (add-hook 'org-mode-hook #'(lambda ()
                                 (visual-line-mode)
                                 (org-indent-mode))))
#+end_src

** Packages / Helper Functions / Tools found on the web / worg
*** org-protocol
Let other tools use emacs client to interact.
#+begin_src emacs-lisp
(require 'org-protocol)
#+end_src

**** Setup on Mac
Lots of old and imprecise information found on the web. Here are the important bits done correctly (as of Oct 2021):
***** Set up the system to handle org-protocol URLs.
Making the system open =org-protocol= links with a personalized tool is done with a /Script/ saved as an /Application/ as described on [[https://github.com/xuchunyang/setup-org-protocol-on-mac#step-1-create-an-application][this page]].
You need to find the path to =emacsclient= which is =/Applications/Emacs.app/Contents/MacOS/bin/emacsclient= if you install GNU Emacs for Max OSX.
***** Format the URL to send to Emacs
The browser needs to be instructed to call the given URL with some information abotu the page. This is done with a bookmarklet that consists of only Javascript. I had to inspect the source of =org-protocol= to find out that the current format (new-style) is a regular URL with query parameters:

#+begin_example
org-protocol:///capture?key1=value1&key2=value2
#+end_example

This consists of

1. The /protocol/ bit =org-protocol://=
2. The /path/ bit, which maps to a set of defined sub-protocols. Pre-defined ones are =store-link=, =capture=, =open-source=
3. The /query args/, escaped properly to not interfere with URL structure.

Each sub protocol handles a different set of query args:
=capture= :: =url= (the /link/ to the web page), =title= (the /description/ of the webpage), =body= (the /initial/ highlighting on that page) and =template= (the org capture template key to use)
=store-link= :: =url= and =title= (can then be inserted as regular link with =C-c C-l=)
=open-source= :: =url= which points to the file to open in a URL format (file:///home/user/.bashrc)

Should this be misformatted in some way, you might get the infamous and unfortunately unhelpful message
#+begin_example
Greedy org-protocol handler.  Killing client.
No server buffers remain to edit.
#+end_example

The best way is to craft a correct URL, and call emacsclient on the command line, jsut to assert that this part is working. The browser gives absolutely no hint at what could have gone wrong.

***** Setup the bookmarklet
The Javascript bookmarklet should then be like this:
#+name: bookmarklet_url
#+begin_example
  "org-protocol://capture?" +
             new URLSearchParams({
                   template: "W",
                   url: location.href,
                   title: document.title,
                   body: selection()})
#+end_example

#+name: plain_selection
#+begin_example
() => {
  return window.getSelection();
}
#+end_example

Store this following test as the URL part of a browser bookmark.
#+name: minify
#+begin_src bash :var urlexpr=bookmarklet_url :var jslib=plain_selection :results output verbatim :tangle no
  echo "javascript:location.href=(() => { var selection=${jslib}; return ${urlexpr} })()" \
        | sed -e 's,  //.*,,g' \
        | tr '\n' ' ' \
        | sed -e 's/  */ /g' -e 's/; *;/;/g' -e 's/: /:/g' -e 's/; *}/}/g' -e 's/ *\([({}=,\+;]\) */\1/g' \
        | sed -e 's/userSelection/u/g' -e 's/clonedSelection/c/g' -e 's/range/r/g'
#+end_src

#+RESULTS: minify
: javascript:location.href=(()=>{var selection=()=>{return window.getSelection()};return "org-protocol://capture?"+new URLSearchParams({template:"W",url:location.href,title:document.title,body:selection()})})()

***** The capture templates
This is only needed for the =capture= sub-protocol. You need to define a capture template that will be used to insert the blob from what was taken on the webpage.
#+begin_src emacs-lisp :tangle no
  ;; Example capture for plain capture:
  (setq org-capture-templates
        `(("W" "Web Clips"
           entry (file+headline ,(org-relative "Inbox.org") "Web Clips")
           "* %:description\n%U\n[[%:link]]\n%:type %:query\n%?%:initial\n")
        ;; possibly other templates
        ))
#+end_src
This defines a =W= template and accepts several parameters, which are just a mapping from the ones passed to the URL. With the new style of URLs, this mapping is just an needless annoyance though.

|---------------+--------------------|
| URL query arg | template parameter |
|---------------+--------------------|
| url           | %:link             |
| title         | %:description      |
| body          | %:initial          |
| template      | <not accessible>   |
|---------------+--------------------|
|               | %:type             |
|               | %:orglink          |
|---------------+--------------------|

All the other org-mode placeholders are all usable, like =%U= that inserts an inactive timestamp.

**** Make it support HTML
Seems there is a way to get the selection HTML on [[https://snipplr.com/view/10912/get-html-of-selection][Get HTML Of Selection]].

#+name: bookmarklet_html_url
#+begin_example
  "org-protocol://html-capture?" +
             new URLSearchParams({
                   template: "H",
                   url: location.href,
                   title: document.title,
                   body: selection()})
#+end_example

***** Make the bookmarklet return HTML
#+name: html_selection
#+begin_example
() => {
  var userSelection, range;
  if (window.getSelection) {
    // W3C Ranges
    userSelection = window.getSelection ();
    // Get the range:
    if (userSelection.getRangeAt) {
      range = userSelection.getRangeAt (0);
    } else {
      range = document.createRange ();
      range.setStart (userSelection.anchorNode, userSelection.anchorOffset);
      range.setEnd (userSelection.focusNode, userSelection.focusOffset);
    }
    // And the HTML:
    var clonedSelection = range.cloneContents ();
    var div = document.createElement ('div');
    div.appendChild (clonedSelection);
    return div.innerHTML;
  } else if (document.selection) {
    // Explorer selection, return the HTML
    userSelection = document.selection.createRange ();
    return userSelection.htmlText;
  } else {
    return '';
  }
}
#+end_example

#+call: minify(urlexpr=bookmarklet_html_url, jslib=html_selection) :results output verbatim

#+RESULTS:
: javascript:location.href=(()=>{var selection=()=>{var u,r;if(window.getSelection){u=window.getSelection();if(u.getRangeAt){r=u.getRangeAt(0)}else{r=document.createRange();r.setStart(u.anchorNode,u.anchorOffset);r.setEnd(u.focusNode,u.focusOffset)}var c=r.cloneContents();var div=document.createElement('div');div.appendChild(c);return div.innerHTML}else if(document.selection){u=document.selection.createRange();return u.htmlText}else{return ''}};return "org-protocol://html-capture?"+new URLSearchParams({template:"H",url:location.href,title:document.title,body:selection()})})()

***** Handle the receiving side of the protocol
This is a cleaned-up version of the new style capture.

****** Code to process the html-capture protocol
#+begin_src emacs-lisp
  (defun paf/html-to-org-markup (html)
    "Turns HTML markup into Org markup"
    (let ((substitutions '(("+" . " ")
                           ("\n" . " ")
                           ("<p>" . "")
                           ("</p>" . "\n")
                           ("<br/?>" . "\n")
                           ("<code>\\([^<]*\\)</code>" . "=\\1=")
                           ("</?b>" . "*")
                           ("</?i>" . "/")
                           ;; ("" . "")
                           ))
          ;; Cleanup removes unwanted remaining markup.
          (cleanup '(("</?[^>]*>" . " ")
                     ("  *" . " "))))
      (dolist (elt substitutions html)
        (setq html (replace-regexp-in-string (car elt) (cdr elt) html)))
      (dolist (elt cleanup html)
        (setq html (replace-regexp-in-string (car elt) (cdr elt) html)))))

  ;; An expression to test the above function
  ;;  (paf/html-to-org-markup "<p>Some+<b>notes</b>+<pre><code>here</code></pre></p>Q")

  (defun paf/html-cleanup (html)
    (replace-regexp-in-string "+" " " html))

  (defun paf/org-protocol-html-capture (info)
    "Process an org-protocol://html-capture style url with INFO.

  The sub-protocol used to reach this function is set in
  `org-protocol-protocol-alist'.

  This function detects an URL, with the following parameters:
    javascript:location.href = 'org-protocol://html-capture?' +
       new URLSearchParams({
          template: 'W',
          url:location.href,
          title:document.title,
          body:html_selection()})
  "
    (let* ((parts
            (pcase (org-protocol-parse-parameters info)
              ;; New style links are parsed as a plist.
              ((let `(,(pred keywordp) . ,_) info) info)))
           (template (or (plist-get parts :template)
                         org-protocol-default-template-key))
           (url (and (plist-get parts :url)
                     (org-protocol-sanitize-uri (plist-get parts :url))))
           (type (and url
                      (string-match "^\\([a-z]+\\):" url)
                      (match-string 1 url)))
           (title (or (paf/html-to-org-markup (plist-get parts :title)) ""))
           (html (or (paf/html-cleanup (plist-get parts :body)) ""))
           (body (or (paf/html-to-org-markup (plist-get parts :body)) ""))
           (orglink
            (if (null url) title
              (org-link-make-string url (or (org-string-nw-p title) url))))
           ;; Avoid call to `org-store-link'.
           (org-capture-link-is-already-stored t))
      ;; Only store link if there's a URL to insert later on.
      (when url (push (list url title) org-stored-links))
      (org-link-store-props :type type
                            :url url
                            :title title
                            :orglink orglink
                            :body body
                            :html html
                            :query parts)
      (raise-frame)
      (org-capture nil template)
      (message "HTML item captured.")
      ;; Make sure we do not return a string, as `server-visit-files',
      ;; through `server-edit', would interpret it as a file name.
      nil))

  ;; Register the new protocol
  (setq org-protocol-protocol-alist
        '(("html-capture"
           :protocol "html-capture"
           :function paf/org-protocol-html-capture)))
#+end_src

#+begin_src bash :tangle bash/install_deps.sh
  # Install PanDoc
  if [[ "$(uname -m)" == "x86_64" ]]; then
    install_pkg pandoc
  fi
#+end_src

This is also a very crude way of doing it. Better would be to detect the presence of PanDoc, and then use that. An idea is [[https://stackoverflow.com/questions/20336581/paste-html-into-org-mode-as-org-mode-markup][here]], mostly this code:

#+begin_src emacs-lisp :tangle no
  (defun kdm/html2org-clipboard ()
    "Convert clipboard contents from HTML to Org and then paste (yank)."
    (interactive)
    (setq cmd "osascript -e 'the clipboard as \"HTML\"' | perl -ne 'print chr foreach unpack(\"C*\",pack(\"H*\",substr($_,11,-3)))' | pandoc -f html -t json | pandoc -f json -t org")
    (kill-new (shell-command-to-string cmd))
    (yank))
#+end_src

****** Setup the capture template
This new protocol can be handled with this capture template:
#+begin_src emacs-lisp :tangle no
  ;; Example capture for HTML capture:
  (setq org-capture-templates
        `(("H" "HTML Clips"
           entry (file+headline "Inbox.org" "HTML Clips")
           "* %:title\n%U\nurl: [[%:url]]\ntype: %:type\n****text\n?%:body\n**** html\n%:html")
        ;; possibly other templates
        ))
#+end_src

This defines a =H= template and accepts several parameters, which are just a mapping from the ones passed to the URL.
This uses the new style URL, as well as no translation of the arguments.

|---------------+--------------------+----------------------------------------|
| URL query arg | template parameter | What is it?                            |
|---------------+--------------------+----------------------------------------|
| url           | %:url              | The page's URL                         |
| title         | %:title            | The page's title                       |
| body          | %:body             | The selected part, as org text         |
| html          | %:html             | The selected text, as original HTML    |
| template      | <not accessible>   | The capture template to use            |
|---------------+--------------------+----------------------------------------|
|               | %:type             | The protocol type of the URL           |
|               | %:orglink          | A ready-to-insert org link to the page |
|---------------+--------------------+----------------------------------------|

All the other org-mode placeholders are all usable, e.g. =%U= that inserts an inactive timestamp.

*** Org-relative file helper function
#+begin_src emacs-lisp
(defun org-relative (filename)
  "Compute an expanded absolute file path for org files"
  (expand-file-name filename org-directory))
#+end_src

*** Adjust tags on the right

#+begin_src emacs-lisp
  ;; Setting this to t makes org-refile not work...
  (setq org-auto-align-tags nil)
  (setq org-tags-column 65)
#+end_src

**** CANCELLED Update =org-set-tags-to=
CLOSED: [2021-09-30 Thu 10:37]
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2021-09-30 Thu 10:37] \\
  I use the built-in stuff now.
- State "TODO"       from              [2019-01-12 Sat 12:08]
:END:
[[https://orgmode.org/worg/doc.html#org-set-tags-to][=org-set-tags-to=]] is gone, and =org-set-tags= with > 1 args is not working.
Not sure what to replace it with though...

*** Archiving
Make sure archiving preserves the same tree structure, including when archiving subtrees.
This is found on [[https://gist.github.com/edgimar/072d99d8650abe81a9fe7c8687c0c993][github Gist from edgimar]]

**** TODO Does not seem to work with archiving org-gcal files.
:LOGBOOK:
- State "TODO"       from              [2021-06-03 Thu 00:28]
:END:

#+begin_src emacs-lisp :tangle no
  (load-file (expand-file-name "archive-with-ancestors.el"
                               paf-lisp-directory)
  ;; Set the function to use for org-archive-default  (C-c C-x C-a)
  ;;(setq org-archive-location (concat org-directory "/Archive/%s_archive::* Archived"))

  ;; Auto-save the archive buffer
  (setq org-archive-subtree-save-file-p t)

  ;; (setq org-archive-save-context-info '(time etc.))
#+end_src

*** Refresh Agenda
Refresh org-mode agenda regularly.
[[https://orgmode.org/worg/org-hacks.html#orgab827a7][source on worg]]
There are two functions that supposedly do the same.
#+begin_src emacs-lisp
  (defun kiwon/org-agenda-redo-if-visible ()
    "Call org-agenda-redo function even in the non-agenda buffer."
    (interactive)
    (let ((agenda-window (get-buffer-window org-agenda-buffer-name t)))
      (when agenda-window
        (with-selected-window agenda-window (org-agenda-redo)))))
#+end_src

*** Agenda Files
#+begin_src emacs-lisp
  ;; Make sure org-agenda-files is defined.
  (if (eq 0 (length org-agenda-files))
      (setq org-agenda-files
            (list (expand-file-name org-directory)
                  (expand-file-name "Auto" org-directory)
                  (expand-file-name "Meeting" paf-roam-directory))))

  (defun org-get-first-agenda-file ()
    (interactive)
    (let* ((num-files (length org-agenda-files))
           (the-file (if (eq num-files 0)
                         org-directory
                       (elt org-agenda-files 0))))
      (find-file the-file)))
#+end_src

*** calfw-org
#+begin_src emacs-lisp
  (use-package calfw
    :ensure t
    :config
    (setq
     calendar-month-name-array
     ["Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"]
     calendar-day-name-array ["Sun" "Mon" "Tue" "Wed" "Thu" "Fri" "Sat"]
     calendar-week-start-day 1 ; 0:Sunday, 1:Monday
     cfw:fchar-junction ?┼
     cfw:fchar-vertical-line ?│
     cfw:fchar-horizontal-line ?─
     cfw:fchar-left-junction ?├
     cfw:fchar-right-junction ?┤
     cfw:fchar-top-junction ?┬
     cfw:fchar-top-left-corner ?┌
     cfw:fchar-top-right-corner ?┐
     ))

  (use-package calfw-org
    :ensure t
    :after calfw)
#+end_src

*** org-gtasks
Should follow this git repo: [[https://github.com/JulienMasson/org-gtasks][org-gtasks]]
I have it as a submodule, as it's not yet available on MELPA.

To help debug, use this before running things:
=(setq request-log-level 'debug)=

#+begin_src emacs-lisp
  (use-package request
    :ensure t)
  (use-package deferred
    :ensure t)
  (use-package request-deferred
    :ensure t)
  (load-file (expand-file-name "org-gtasks/org-gtasks.el" paf-modules-directory))

  ;; Helper to sync all task lists for an account
  (defun paf/org-gtasks-sync (account_name)
    "Synchronizes all tasklists for the account with given name."
    (interactive)
    (let* ((account (org-gtasks-find-account-by-name account_name)))
      (org-gtasks-pull account "ALL")
      (org-gtasks-push account "ALL")))
#+end_src

I have this currently in my `~/.emacs`:
#+begin_src emacs-lisp :tangle no
(use-package org-gtasks
  :init
  (org-gtasks-register-account
     :name "pascal"
     :directory "~/OrgFiles/GTasks/"
     :client-id "XXX"
     :client-secret "XXX"))
#+end_src

If you need to debug oauth2, then this will make the request/response be printed to the  *Messages* buffer:

#+begin_src emacs-lisp :tangle no
  (setenv "GPG_AGENT_INFO")
  (custom-set-variables '(request-log-level 'blather)
                        '(request-message-level 'blather))
  (setq request-log-level 'debug)
#+end_src

*** Search in org
**** org-rifle
[[https://github.com/alphapapa/org-rifle][org-rifle]] is the swiss-army knife for searching in an org-file.

*** org-roam (v2)
My cheat sheet for =org-roam=

All keys prefixed with =C-c n=

|-------------------+---------------|
| Function          | =C-c n <key>= |
| <l>               |      <c>      |
|-------------------+---------------|
| Toggle side panel |       l       |
|-------------------+---------------|
| Find/create       |       f       |
| Insert link       |       i       |
| Capture           |       c       |
|-------------------+---------------|
| Graph             |       g       |
| Switch to buffer  |       b       |
|-------------------+---------------|


#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :custom
    (org-roam-directory (file-truename paf-roam-directory))
    :init (setq org-roam-v2-ack t)
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n b" . org-roam-switch-to-buffer)
           ("C-c n f" . org-roam-node-find)
           ("C-c n c" . org-roam-capture)
           ("C-c n g" . org-roam-graph)
           ("C-c n j" . org-roam-dailies-capture-today)
           ("C-c n i" . org-roam-node-insert))
    :config
    (org-roam-db-autosync-enable)
    (require 'org-roam-protocol))
#+end_src

These are some extensions to make org-agenda find info in roma files in a reasonable time.
Found on [[https://magnus.therning.org/2021-07-23-keeping-todo-items-in-org-roam-v2.html][Magnus Therning's website]].
**** DONE This is currently broken as OrgRoam V2 has changed in a non-backwards-compatible way...
CLOSED: [2021-09-27 Mon 20:42]
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-09-27 Mon 20:42]
- State "TODO"       from              [2021-07-22 Thu 16:09]
:END:

#+begin_src emacs-lisp
  (use-package org-roam-extras
    :load-path (lambda () (expand-file-name paf-lisp-directory))
    :after org-roam
    :config
    (setq roam-extras-todo-tag-name "project")
    ;; set the todo tag to roam fiels when they contain tasks
    (add-hook 'find-file-hook #'roam-extras/update-todo-tag)
    (add-hook 'before-save-hook #'roam-extras/update-todo-tag)
    ;; update the agenda-files just before constructing the agenda
    (advice-add 'org-agenda :before #'roam-extras/add-todo-files)
    (advice-add 'org-agenda :after #'roam-extras/restore-todo-files)
    )
#+end_src

EmacSQL will need to get its C-binary compiled, and needs supporting tools. Note that 'tcc' for Termux seems not complete enough for the job.
#+begin_src bash :tangle bash/install_deps.sh
  # org-roam needs this binary
  if [[ "$(uname -o)" == "Android" ]]; then
      install_pkg -x sqlite3 sqlite
  else
      install_pkg -x sqlite3 sqlite3
  fi
  # Make sure there is a C compiler for emacsql-sqlite
  [[ -n "$(which cc)" ]] || install_pkg -x cc clang
#+end_src
*** org-ref
#+begin_src emacs-lisp
  (use-package org-ref
    :ensure t)
#+end_src

*** org-clock-convenience
#+begin_src emacs-lisp
  (use-package org-clock-convenience
    :ensure t
    :bind (:map org-agenda-mode-map
             ("<S-right>" . org-clock-convenience-timestamp-up)
             ("<S-left>" . org-clock-convenience-timestamp-down)
             ("[" . org-clock-convenience-fill-gap)
             ("]" . org-clock-convenience-fill-gap-both)))
#+end_src

*** org-kanban
#+begin_src emacs-lisp :tangle no
  (use-package org-kanban
    :ensure t)
#+end_src

*** org-board
Archive entire sites locally with `wget`.
#+begin_src emacs-lisp :tangle no
  (use-package org-board
    :ensure t
    :config
    (global-set-key (kbd "C-c o") org-board-keymap))
#+end_src

This is the needed tool used to fetch a URL's content.
#+begin_src bash :tangle bash/install_deps.sh
# wget used for org-board archiving.
install_pkg -x wget wget
#+end_src

*** org-reveal
This presentation generator is still under review (by me).

#+begin_src bash :noweb yes :tangle bash/install_deps.sh
# Install reveal.js
if [[ -d "${HOME}/reveal.js" ]]; then
  echo "Reveal already installed"
else
  (cd ~/ && git clone https://github.com/hakimel/reveal.js.git)
fi
#+end_src

#+begin_src emacs-lisp
  (use-package ox-reveal
    :ensure t
    :after (htmlize)
    :config
    (setq org-reveal-root (expand-file-name "~/reveal.js")))

  (use-package htmlize
    :ensure t)
#+end_src

*** org-crypt
#+begin_src emacs-lisp
  ;;(require 'epa-file)
  ;;(epa-file-enable)
  (use-package org-crypt
    :config
    (org-crypt-use-before-save-magic)
    (setq org-crypt-key "") ; to use symetric encryption unless key specified
    (setq org-tags-exclude-from-inheritance '("crypt")))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package sensitive-mode
    :load-path (lambda () (expand-file-name paf-lisp-directory)))

  (setq auto-mode-alist
        (append '(("\\.gpg$" . sensitive-mode)
                  ("\\.crypt\\.org$" . sensitive-mode))
                auto-mode-alist))
#+end_src

*** iimage (M-I)
Make the display of images a simple key-stroke away.
#+begin_src emacs-lisp
  (defun paf/org-toggle-iimage-in-org ()
    "display images in your org file"
    (interactive)
    (if (face-underline-p 'org-link)
        (set-face-underline 'org-link nil)
      (set-face-underline 'org-link t))
    (iimage-mode 'toggle))

  (use-package iimage
    :config
    (add-to-list 'iimage-mode-image-regex-alist
                 (cons (concat "\\[\\[file:\\(~?" iimage-mode-image-filename-regex
                               "\\)\\]")  1))
    (add-hook 'org-mode-hook (lambda ()
                               ;; display images
                               (local-set-key "\M-I" 'paf/org-toggle-iimage-in-org)
                              )))
#+end_src

*** org-collector
Collect properties of Org structure items into tables. See documentation in the file.
#+begin_src emacs-lisp
(load-file (expand-file-name "org-collector.el" paf-lisp-directory))
#+end_src

*** orgtbl-aggregate
Do some transformations of an org-table into another one.
See the project's [[https://github.com/tbanel/orgaggregate][homepage]]
#+begin_src bash
  (use-package orgtbl-aggregate
   :ensure t)
#+end_src

*** org-listcruncher
A long sought after package to help plan scenarios.
#+begin_src emacs-lisp
  (use-package org-listcruncher
    :ensure t)
#+end_src
*** Set date as header for org-gcal event
#+begin_src emacs-lisp
  (defun paf/org-timestamp-in-entry ()
    "Find the first timestamp in an entry.

  Returns the timestamp or nil of none was found."
    (interactive)
    (let* ((org-elem (save-excursion
                       (org-back-to-heading)
                       (org-element-at-point)))
           (org-heading (plist-get org-elem 'headline))
           (elem-min (plist-get org-heading :begin))
           (elem-max (plist-get org-heading :end))
           (timestamp-re (org-re-timestamp 'all)))
      (save-excursion
        (goto-char elem-min)
        (if (re-search-forward timestamp-re elem-max t)
            (let ((match-pos (match-beginning 0)))
              (goto-char match-pos)
              (org-element-timestamp-parser)
              ;;(plist-get (org-element-timestamp-parser) 'timestamp)
              )))))

  (defun paf/replace-current-heading (new-text)
    "Replace heading at point by a new text."
    (interactive "sNew Title: ")
    (when (org-at-heading-p)
      (let ((hl-text (nth 4 (org-heading-components))))
        (unless (or (null hl-text)
                    (org-string-match-p "^[ \t]*:[^:]+:$" hl-text))
          (beginning-of-line)
          (search-forward hl-text (point-at-eol))
          (replace-string hl-text new-text
           nil (- (point) (length hl-text)) (point))))))

  (defun paf/org-gcal-date-as-heading ()
    "This will get the org-gcal date and replace the heading with it."
    (interactive)
    (save-excursion
      (let* ((time-desc (org-gcal--get-time-and-desc))
             (start-date (plist-get time-desc :start))
             (elem-timestamp (paf/org-timestamp-in-entry))
             (formatted-date
              (if start-date
                  (org-gcal--format-iso2org start-date org-gcal-local-timezone)
                (org-timestamp-format elem-timestamp (org-time-stamp-format t t)))))
        (org-back-to-heading)
        (paf/replace-current-heading (format "[%s]"
                                             (substring formatted-date 1 (- (length formatted-date) 1)))))
      ))
#+end_src

*** org-present
This is following the excellent video from [[https://systemcrafters.net/emacs-tips/presentations-with-org-present/][System Crafters]].
#+begin_src emacs-lisp
  (use-package visual-fill-column
    :ensure t
    :config
    (setq visual-fill-column-width 110
          visual-fill-column-center-text t))

  ;; Load org-faces to make sure we can set appropriate faces
  (require 'org-faces)

  ;; Hide emphasis markers on formatted text
  (setq org-hide-emphasis-markers t)

  (defun paf/org-present-start ()
    ;; Center text
    (visual-fill-column-mode 1)
    (visual-line-mode 1)
    (scroll-bar-mode 0)
    ;; Tweak font sizes
    (setq-local face-remapping-alist '((default (:height 1.5) variable-pitch)
                                       (header-line (:height 4.0) variable-pitch)
                                       (org-document-title (:height 1.75) org-document-title)
                                       (org-code (:height 1.55) org-code)
                                       (org-verbatim (:height 1.55) org-verbatim)
                                       (org-block (:height 1.25) org-block)
                                       (org-block-begin-line (:height 0.7) org-block)))
    ;; Set a blank header line string to create blank space at the top
    (setq header-line-format " "))

  (defun paf/org-present-end ()
    ;; reset the text centring
    (visual-fill-column-mode 0)
    (visual-line-mode 0)
    (scroll-bar-mode 1)
    ;; Reset font customizations
    (setq-local face-remapping-alist '((default variable-pitch default)))
    ;; Clear the header line format by setting to `nil'
    (setq header-line-format nil))

  (defun paf/org-present-prepare-slide (buffer-name heading)
    ;; Show only top-level headlines
    (org-overview)

    ;; Unfold the current entry
    (org-show-entry)

    ;; Show only direct subheadings of the slide but don't expand them
    (org-show-children))

  (use-package org-present
    :ensure t
    :config
    (add-hook 'org-present-mode-hook 'paf/org-present-start)
    (add-hook 'org-present-mode-quit-hook 'paf/org-present-end)
    (add-hook 'org-present-after-navigate-functions 'paf/org-present-prepare-slide))

#+end_src

*** valign
This enables aligining tables in a pixel-perfect way.
#+begin_src emacs-lisp
  (use-package valign
    :ensure t
    :hook (org-mode-hook . valign-mode)
    :config
    (setq valign-fancy-bar t))
#+end_src

*** easy-draw

This is a nice package to draw diagrams directly in emacs. Coming from this github repos:
[[https://github.com/misohena/el-easydraw][el-easydraw]].

[[edraw:data=H4sIAIcLC2QAA6WSzW6DMAzHXyVyr5QkQLtRES67bg/BmgARDKqQNfD28/jY2MQ0qT0klmX7/7OdJN21IE5LWwo4HBmQUumitAKiAJ2rMp1uGwHc50D6t7rpBJTWXk6UOud8F/qtKWjAGKMoNKec+lo31VYij+OYjlFIE6PO9m90LwDvYbxzXdcCdnmeA+msaSsloGkbBURLAUqazO1fs3NVmPa9kUBomhTrUCuHhfez3CCFI8AMk0U3mqifZu6NR6vejt/tMJbnD8FI25Cek6SUmxj+OHH4GnT8BbpJOWL/T4DCl8yWX8I7fJdltfu5KFpIExW3+cID5nF2d/0TP6ANGcEleDj0Ym/WDaOx/hlH92YZWuDBL5l+AGuIuO3hAgAA]]

#+begin_src emacs-lisp
  ;(use-package eieio
  ;  :ensure t)
  (use-package svg
    :ensure t)
  (use-package widget-mvc
    :ensure t)

  (use-package edraw-org
    :load-path (lambda () (expand-file-name "el-easydraw" paf-modules-directory))
    :after (org)
    :requires (svg)
    :config (edraw-org-setup-default))
#+end_src

*** org sticky headers
Keeps the header visible even when it gets off the visible part of the buffer.
#+begin_src emacs-lisp
  (use-package org-sticky-header
    :ensure t)
#+end_src
** My Setup
These are mostly org-config specific to me, myself and I.
*** Key mappings
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c b") 'org-iswitchb)
  ;; added because on Chromoting/i3, Alt-<up> and Alt-<down> are changin window focus.
  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key (kbd "C-<up>") 'org-move-subtree-up)
              (local-set-key (kbd "C-<down>") 'org-move-subtree-down)
              (local-set-key (kbd "C-c l") 'org-store-link)
              (local-set-key (kbd "C-c C-l") 'org-insert-link)))
#+end_src

*** Colors and faces
This colors the code blocks a bit more visibly.
#+begin_src emacs-lisp
  (set-face-attribute 'org-block-begin-line nil :background "gray17")
  (set-face-attribute 'org-block            nil :background "gray22")
  (set-face-attribute 'org-block-end-line   nil :background "gray17")
#+end_src

This renders property drawers less "in your face"
#+begin_src emacs-lisp
    (set-face-attribute 'org-drawer   nil
                        :foreground "gray50" ;; "RoyalBlue3"
                        :height 0.7)
#+end_src

This makes the all-day events stand-out and be displayed before the calendar.
#+begin_src emacs-lisp
  (set-face-attribute 'org-agenda-calendar-sexp nil
                      :foreground "dark orange")
  ;;(setq org-sort-agenda-notime-is-late nil)
#+end_src

*** Links by ID
#+begin_src emacs-lisp
  (setq org-id-link-to-org-use-id 'create-if-interactive)
#+end_src

*** Display settings
my config for display.
#+begin_src emacs-lisp
  (setq org-hide-leading-stars 't)
  (setq org-log-done 't)
  (setq org-startup-folded 't)
  (setq org-startup-indented 't)
  (setq org-startup-folded 't)
  (setq org-ellipsis "...")

  (setq org-time-stamp-formats '("<%Y-%m-%d %a>" . "<%Y-%m-%d %a %H:%M>"))
  (setq org-time-stamp-custom-formats '("<%Y-%m-%d %a>" . "<%Y-%m-%d %a %H:%M>"))
#+end_src

#+begin_src emacs-lisp
  (use-package org-indent
    :ensure nil
    :custom
    (org-indent-indentation-per-level 2))
#+end_src

#+begin_src emacs-lisp
  (defun paf/org-align-all-tags ()
    "Align tags at the end of the line, or so."
    (interactive)
    (org-align-tags t))
#+end_src

*** org-habit
#+begin_src emacs-lisp
  (use-package org-habit
    :config
    (setq org-habit-graph-column 38)
    (setq org-habit-preceding-days 35)
    (setq org-habit-following-days 10)
    (setq org-habit-show-habits-only-for-today nil))
#+end_src

*** bash command
#+begin_src emacs-lisp
(setq org-babel-sh-command "bash")
#+end_src

*** org-clock properties
clock stuff into a drawer.
#+begin_src emacs-lisp
  (setq org-log-into-drawer t)
  (setq org-clock-into-drawer "CLOCK")
#+end_src

*** open first agenda file
F12 open the first agenda file
#+begin_src emacs-lisp
  (global-set-key [f12] 'org-get-first-agenda-file)
  ; F12 on Mac OSX displays the dashboard, so add Control F12
  (global-set-key [C-f12] 'org-get-first-agenda-file)
  ; On a Chromebook that has no F-keys
  (global-set-key (kbd "C-<XF86Tools>") 'org-get-first-agenda-file)
  (global-set-key (kbd "C-p f") 'org-get-first-agenda-file)
#+end_src

*** org-secretary
This is my version of the org-secretary.
I don't use it anymore.
#+begin_src emacs-lisp :tangle no
  (use-package paf-secretary
    :load-path paf-lisp-directory
    :bind (("\C-cw" . paf-sec-set-with)
           ("\C-cW" . paf-sec-set-where)
           ("\C-cj" . paf-sec-tag-entry))
    :config
    (setq paf-sec-me "paf"))

  (setq org-tag-alist '(("PRJ" . ?p)
                        ("DESIGNDOC" . ?D)
                        ("Milestone" . ?m)
                        ("DESK" . ?d)
                        ("HOME" . ?h)
                        ("VC" . ?v)))
#+end_src

*** task tracking
Track task dependencies, and dim them in the agenda.
#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
(setq org-agenda-dim-blocked-tasks 'invisible)
#+end_src

*** effort & columns mode
#+begin_src emacs-lisp
(setq org-global-properties
      '(("Effort_ALL". "0 0:10 0:30 1:00 2:00 4:00 8:00 16:00")))
(setq org-columns-default-format
      "%TODO %30ITEM %3PRIORITY %6Effort{:} %10DEADLINE")
#+end_src

*** org-todo keywords
#+begin_src emacs-lisp
    (setq org-todo-keywords '(
       (sequence "TODO(t!)" "NEXT(n!)" "STARTED(s!)" "WAITING(w!)" "AI(a!)" "LIVE(l!)" "|" "DONE(d!)" "CANCELLED(C@)" "DEFERRED(D@)" "SOMEDAY(S!)" "FAILED(F!)" "REFILED(R!)")
       ;; For publications
       (sequence "APPLIED(A!)" "WAITING(w!)" "ACCEPTED" "|" "REJECTED" "PUBLISHED")
       ;; For tracking other's tasks
       (sequence "TASK(m!)" "ACTIVE" "|" "DONE(d!)" "CANCELLED(C@)" )
    ))

    (setq org-tags-exclude-from-inheritance '("PRJ" "REGULAR")
          org-use-property-inheritance '("PRIORITY")
          org-stuck-projects '("+PRJ/-DONE-CANCELLED"
                               ;; it is considered stuck if there is no next action
                               ("NEXT" "STARTED" "TASK") ()))

    (setq org-todo-keyword-faces
          '(
            ("TODO" . (:foreground "purple" :weight bold))
            ("TASK" . (:foreground "steelblue" :weight bold))
            ("NEXT" . (:foreground "red" :weight bold))
            ("STARTED" . (:foreground "green" :weight bold))
            ("WAITING" . (:foreground "orange" :weight bold))
            ("SOMEDAY" . (:foreground "steelblue" :weight bold))
            ("REFILED" . (:foreground "gray"))
            ("MAYBE" . (:foreground "steelblue" :weight bold))
            ("AI" . (:foreground "red" :weight bold))
            ("LIVE" . (:foreground "green" :weight bold))
            ("NEW" . (:foreground "orange" :weight bold))
            ("RUNNING" . (:foreground "orange" :weight bold))
            ("WORKED" . (:foreground "green" :weight bold))
            ("FAILED" . (:foreground "red" :weight bold))
            ;; For publications
            ("APPLIED" . (:foreground "orange" :weight bold))
            ("ACCEPTED" . (:foreground "orange" :weight bold))
            ("REJECTED" . (:foreground "red" :weight bold))
            ("PUBLISHED" . (:foreground "green" :weight bold))
            ;; Other stuff
            ("ACTIVE" . (:foreground "darkgreen" :weight bold))
            ("FLAG_GATED" . (:foreground "orange" :weight bold))
            ))
#+end_src

*** org-super-agenda
This enables a more fine-grained filtering of the agenda items.
#+begin_src emacs-lisp
  (use-package org-super-agenda
    :ensure t
    :after org-habit
    :config
    (org-super-agenda-mode t))

  (custom-set-faces
   '(org-super-agenda-header ((t (:inherit org-agenda-structure :overline t :height 1.2)))))

#+end_src

*** org-agenda
**** Views
#+begin_src emacs-lisp
  (defun end-of-this-week ()
    (let* ((now (decode-time nil nil t))
           (dow (decoded-time-weekday now))
           (delta-days (make-decoded-time :day (- 6 dow)))
           ((sec min hours day month year dow dst utcoff) (decoded-time-add now delta-days)))
      (format "%04d-%02d-%02d" year month day)))
#+end_src

#+begin_src emacs-lisp
  ;(setq org-agenda-block-separator #x2500)
  (setq org-agenda-block-separator " ")
  (setq org-agenda-custom-commands
        '(("T" "Hot Today"
           ((agenda nil ((org-agenda-span 'day)
                         (org-agenda-skip-function
                          '(org-agenda-skip-entry-if 'deadline))
                         ))
            (agenda nil
                    ((org-agenda-entry-types '(:deadline))
                     (org-agenda-span 'day)
                     (org-agenda-time-grid nil)
                     (org-agenda-show-all-dates nil)
                     (org-agenda-format-date "")
                     (org-deadline-warning-days 7)
                     (org-agenda-overriding-header "  Deadlines")))
            (tags-todo "/WAITING"
                       ((org-agenda-overriding-header "  Waiting")))
            (tags-todo "/STARTED"
                       ((org-agenda-overriding-header "  Ongoing")))
            (tags-todo "/NEXT"
                       ((org-agenda-overriding-header "  Upcoming")))))
          ("t" "Landscape Today"
           ((agenda nil ((org-agenda-span 'day)
                         (org-super-agenda-groups
                          '((:name none
                                   :time-grid t
                                   :date today
                                   :scheduled today)
                            (:discard (:category "Social"))
                            (:discard (:deadline t))
                            (:discard (:habit t))))))
            (alltodo nil ((org-agenda-overriding-header "")
                          (org-super-agenda-groups
                           '(  ;; Each group has an implicit boolean OR operator between its selectors
                             (:name "Deadlines"
                                    :habit t
                                    :deadline t)
                             (:name "Waiting"
                                    :todo "WAITING")
                             (:name "Working tasks"
                                    :todo "STARTED"
                                    :todo "NEXT")
                             (:name "Meet and Re-greet"
                                    :and (:category "Social"
                                          :scheduled (past today)))
                             (:name "AIs to sort out"
                                    :take (10 (:todo "AI")))
                             (:discard (:anything))
                             ;; After the last group, the agenda will display items that didn't
                             ;; match any of these groups, with the default order position of 99
                             ))))))
          ("r" "Recurring"
           ((alltodo nil ((org-agenda-overriding-header "")
                          (org-super-agenda-groups
                           '(
                             (:name "Recurring"
                                    :tag "REGULAR")
                             (:name "Deadlines"
                                    :habit t
                                    :deadline t)
                             (:name "Working tasks"
                                    :todo "STARTED"
                                    :todo "NEXT")
                             (:discard (:anything))))))))
          ("R" "Recurring" ((tags "REGULAR"
                                  ((org-agenda-overriding-header "\nRecurring\n")))
                            (tags-todo "/WAITING"
                                       ((org-agenda-overriding-header "\nWaiting\n")))
                            (tags-todo "TODO=\"STARTED\""
                                       ((org-agenda-overriding-header "\Ongoing\n")))
                            (tags-todo "/NEXT"
                                       ((org-agenda-overriding-header "\nUpcoming\n")))))
          ))

  (setq org-agenda-skip-deadline-prewarning-if-scheduled 2)
#+end_src

**** Display location in agenda
From some help on [[https://emacs.stackexchange.com/questions/26249/customize-text-after-task-in-custom-org-agenda-view][this page]] I think this could work:
#+begin_src emacs-lisp
  (defun paf/replace-many-regexp-in-string (text substitutions)
    "Replaces a set of regexps in the text"
    (dolist (elt substitutions text)
      (setq text (replace-regexp-in-string (car elt) (cdr elt) text))))

  (defcustom paf/my-location "ZRH"
    "Location of the office, to filter agenda locations"
    :type 'string
    :group 'paf)

  (require 'seq)
  (defun paf/cleanup-location (loc)
    "Remove unneeded fluff around location"
    (let* ((clean-loc (paf/replace-many-regexp-in-string loc '(("([^)]*)" . "")
                                                               ("\\[[^]]+\\]" . ""))))
           (locs (seq-filter (lambda (e) (string-match-p (regexp-quote paf/my-location) e))
                             (split-string clean-loc ",")))
           (full-loc (mapconcat (lambda (e) (string-trim e)) locs ", ")))
      (paf/replace-many-regexp-in-string full-loc '(("CH-ZRH" . "ZRH")
                                                    ("\\([0-9]+\\)-\\([[a-zA-Z]+]\\)" . "\\1\\2")
                                                    (" *$" . "")))))

  ;; for testing
  ;; (paf/cleanup-location "CH-ZRH-100-2-2-Riff Raff (2) [GVC, Phone], NYC-9TH-5-F - Packrat [GVC]")

  (defun paf/org-agenda-get-location ()
    "Gets the value of the LOCATION property"
    (let* ((loc (org-entry-get (point) "LOCATION"))
           (clean-loc (if loc (paf/cleanup-location loc) "")))
      (if (> (length clean-loc) 0)
          (concat "[" clean-loc "] ")
        "")))

  (defun paf/org-agenda-get-location-print ()
    "Just prints the value of the extracted location to the echo area.
Used for debugging."
    (interactive)
    (message (concat "'" (paf/org-agenda-get-location) "'")))
#+end_src

Also, to set this after org-mode has loaded ([[https://emacs.stackexchange.com/questions/19091/how-to-set-org-agenda-prefix-format-before-org-agenda-starts][see here]]):
#+begin_src emacs-lisp :tangle no
  (with-eval-after-load 'org-agenda
    (add-to-list 'org-agenda-prefix-format
                 '(agenda . "  %-12:c%?-12t%(paf/org-agenda-get-location)")))
#+end_src

**** text formatting
These are some improved rendering of the calendar view.

First, d12frosted's [[https://d12frosted.io/posts/2020-06-24-task-management-with-roam-vol2.html][post]] handles the category length:
#+begin_src emacs-lisp
  (require 'org-roam-extras)
  (defun paf/agenda-category (len)
    (paf/truncate-string (roam-extras/extract-agenda-category) len))
    ;;(paf/truncate-string (or (org-get-category) "") len))

  (with-eval-after-load 'org-agenda
    (setq org-agenda-prefix-format
          '((agenda . " %i %-12(paf/agenda-category 12)%?-12t") ;%(paf/org-agenda-get-location)
            (todo . " %i %-12(paf/agenda-category 12)")
            (tags . " %i %-12(paf/agenda-category 12)")
            (search . " %i %-12(paf/agenda-category 12)"))))
#+end_src

(setq org-agenda-prefix-format
          '((agenda . " %i %-12(paf/agenda-category 12)%?-12t%(paf/org-agenda-get-location)% s")
            (todo . " %i %-12(paf/agenda-category 12)")
            (tags . " %i %-12(paf/agenda-category 12)")
            (search . " %i %-12(paf/agenda-category 12)")))

Displaying a grid of 3 hours seems better, as show by AbstProcDo's [[https://www.reddit.com/r/orgmode/comments/mbs4ia/my_agendatime_grid_segmented_by_3_hours/][post]]:
#+begin_src emacs-lisp
  (setq org-agenda-time-grid
        (quote ((daily today remove-match)
                (600 900 1200 1500 1800 2100)
                " ……………"
                "" ;; ———————————————"
                )))
#+end_src

**** colors and faces
Make the calendar day info a bit more visible and contrasted.
#+begin_src emacs-lisp
;; Faces to make the calendar more colorful.
(custom-set-faces
 '(org-agenda-current-time ((t (:inherit org-time-grid :foreground "yellow" :weight bold))))
 '(org-agenda-date ((t (:inherit org-agenda-structure :background "pale green" :foreground "black" :weight bold))))
 '(org-agenda-date-weekend ((t (:inherit org-agenda-date :background "light blue" :weight bold)))))
#+end_src

**** now marker
A more visible current-time marker in the agenda
#+begin_src emacs-lisp
(setq org-agenda-current-time-string ">>>>>>>>>> NOW <<<<<<<<<<")
#+end_src

**** auto-refresh
#+begin_src emacs-lisp
  ;; will refresh it only if already visible
  (run-at-time nil 180 'kiwon/org-agenda-redo-if-visible)
#+end_src

**** auto-save org files when idle
This will save them regularly when the idle for more than 10 minutes. It will also not run if when the lambda gets called the idle time is then less than 10 minutes.
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            (lambda () (run-with-idle-timer 600 t 'org-save-all-org-buffers)))
#+end_src

**** export
That's the export function to update the agenda view.
#+begin_src emacs-lisp :tangle no
(setq org-agenda-exporter-settings
      '((ps-number-of-columns 2)
        (ps-portrait-mode t)
        (org-agenda-add-entry-text-maxlines 5)
        (htmlize-output-type 'font)))

(defun dmg-org-update-agenda-file (&optional force)
  (interactive)
  (save-excursion
    (save-window-excursion
      (let ((file "~/www/agenda/agenda.html"))
        (org-agenda-list)
        (org-agenda-write file)))))
#+end_src

*** org-duration
#+begin_src emacs-lisp
  (use-package org-duration
    :config
    (setq org-duration-units
          `(("min" . 1)
            ("h" . 60)
            ("d" . ,(* 60 8))
            ("w" . ,(* 60 8 5))
            ("m" . ,(* 60 8 5 4))
            ("y" . ,(* 60 8 5 4 10)))
          )
    (org-duration-set-regexps))
#+end_src

*** OrgRoam templates
#+begin_src emacs-lisp
  (setq org-roam-capture-templates `(
     ("n" "Note" entry
      "* %?"
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                         "#+title: ${title}\n#+filetags: draft\n\n\n")
      :unnarrowed t)
     ("m" "Meeting Collection" entry
      "* %?%^{type}\n"
      :if-new (file+head "Meeting/%<%Y%m%d%H%M%S>-${slug}.org"
                         "#+title: ${title}\n#+filetags: meeting\n\n\n")
      :unnarrowed t)
     ("r" "Reference" entry
      "* %?\n%U\n\n"
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                         "#+title: ${title}\n#+filetags: reference\n\n\n")
      :unnarrowed t)
  ))
#+end_src

*** Capture & refile
Capture and refile stuff, with some templates that I think are useful.

**** Capture
Very nice post on how to get capture templates from a file: [[https://joshrollinswrites.com/help-desk-head-desk/org-capture-in-files/][Org-capture in Files]].

#+begin_src emacs-lisp
  (setq org-default-notes-file (org-relative "Inbox.org"))

  (setq org-capture-templates
        `(("t" "Task"
           entry (file+headline ,(org-relative "Inbox.org") "Tasks")
           "* TODO %?\n%U\n\n%x"
           :clock-resume t)
          ;;
          ("i" "Idea"
           entry (file+headline ,(org-relative "Inbox.org") "Ideas")
           "* SOMEDAY %?\n%U\n\n%x"
           :clock-resume t)
          ;;
          ("m" "Meeting"
           entry (file+headline ,(org-relative "Inbox.org") "Meetings")
           "* %?  :MTG:\n%U\n%^{with}p"
           :clock-in t
           :clock-resume t)
          ;;
          ("s" "Stand-up"
           entry (file+headline ,(org-relative "Inbox.org") "Meetings")
           "* Stand-up  :MTG:\n%U\n\n%?"
           :clock-in t
           :clock-resume t)
          ;;
          ("1" "1:1"
           entry (file+headline ,(org-relative "Inbox.org") "Meetings")
           "* 1:1 %^{With}  :MTG:\n%U\n:PROPERTIES:\n:with: %\\1\n:END:\n\n%?"
           :clock-in t
           :clock-resume t)
          ;;
          ("p" "Talking Point"
           entry (file+headline ,(org-relative "Inbox.org") "Talking Points")
           "* AI %?  :TALK:\n%U\n%^{with}p"
           :clock-keep t)
          ;;
          ("j" "Journal"
           entry (file+olp+datetree ,(org-relative "journal.org"))
           "* %?\n%U"
           :clock-in t
           :clock-resume t
           :kill-buffer t)
          ;;
          ("W" "Web Clips"
           entry (file+headline ,(org-relative "Inbox.org") "Web Clips")
           "* %:description\n%U\n[[%:link]]\n%:type %:orglink\n%?%:initial\n")
          ;;
          ("H" "HTML Clips"
           entry (file+headline ,(org-relative "Inbox.org") "Web Clips")
           "* %:title\n%U\n%:orglink\n\n%?%:body\n")
          ;;
          ))
#+end_src

**** Refile
#+begin_src emacs-lisp
  ;; show up to 2 levels for refile targets, in all agenda files
  (setq org-refile-targets '((org-agenda-files :maxlevel . 2)))
  (setq org-log-refile 'time)

  ;; from: http://doc.norang.ca/org-mode.html
  ;; Exclude DONE state tasks from refile targets
  (defun bh/verify-refile-target ()
    "Exclude todo keywords with a done state from refile targets"
    (not (member (nth 2 (org-heading-components)) org-done-keywords)))

  (setq org-refile-target-verify-function 'bh/verify-refile-target)
#+end_src

***** Implement my own =AI= refiling.
#+begin_src emacs-lisp
  (require 'bookmark)

  (defun paf/refile-ai-targets ()
    "Does an org-refile-copy of an AI, with some linking and side-effects.

          This does add a link to the original =AI= in the new task, as
          well as mark the =AI= as done, and change the refiled target to a
          =TODO=."
    (interactive)
    (org-back-to-heading)
    ;; without this, org-refile fails to setup bookmarks... go figure.
    (bookmark-maybe-load-default-file)
    (let* ((orig-marker (point-marker))
           ;; make sure the to-be-filed entry has an ID
           (orig-id (org-id-get-create)))
      (save-window-excursion
        (org-refile 3 nil nil "Move AI")  ;; 3 => does a copy and not a move
        ;; Now we are back at the orig location, so force change the ID
        ;; (as it has been copied)
        (org-id-get-create t) ;; t => force change
        (org-todo 'done)
        ;; Now take a link with the new forced ID,
        ;; go to the refiled location, and modify the
        ;; refiled entry.
        (let ((orig-link (org-store-link nil)))
          (org-refile-goto-last-stored)
          (org-todo "TODO")
          (org-entry-put (point) "AI" orig-link)))))

  (with-eval-after-load 'org
    (bind-key "C-p a" #'paf/refile-ai-targets org-mode-map))
#+end_src

*** org-babel
What kind of code block languages do I need
#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate 'nil) ; Don't ask before executing

(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   (R . t)
   (dot . t)
   (emacs-lisp . t)
   (gnuplot . t)
   (python . t)
   (ledger . t)
   ;;(sh . t)
   (latex . t)
   (shell . t)
  ))
#+end_src

*** org-export
Add a few formats to the export functionality of org-mode.

content filtering is done by adding a filter function to =org-export-filter-body-functions= (in my =~/.emacs_*.el=)

#+begin_src emacs-lisp
  (use-package ox-odt
    :defer)
  (use-package ox-taskjuggler
    :defer)
  (use-package ox-impress-js
    :defer)
#+end_src

Also make the exported references nicer, using the title as a handle.

#+begin_src emacs-lisp
  (load-file (expand-file-name "org-export-nice-ids.el" paf-lisp-directory))
  (use-package ox
    :config
    (advice-add #'org-export-get-reference :override #'alphapapa/org-export-get-reference))
#+end_src

*** org-publish

#+begin_src emacs-lisp
  (require 'ox-publish)

  (setq paf-status-directory "~/www/org-status/")

  (setq org-publish-project-alist
        '(
          ("project-status"
           :base-directory "~/OrgFiles/"
           :base-extension "org"
           ;;:select-tags "current"
           :publishing-directory "~/www/org-status/"
           :recursive nil
           ;; :preparation-function org-run-source-blocks
           :publishing-function org-html-publish-to-html
           :headline-levels 6)

          ("bigblow-theme"
           :base-directory "~/Apps/org-html-themes/src/bigblow_theme/"
           :base-extension "css\\|js\\|swf\\|png"
           :recursive t
           :publishing-directory "~/www/org-status/"
           :publishing-function org-publish-attachment)

          ("my-status"
           :components ("project-status" "bigblow-theme"))
          ))
#+end_src

*** plant-uml
Tell where PlantUML is to be found. This needs to be downloaded and installed separately, see the [[http://plantuml.com/][PlantUML website]].

You could install the PlantUML JAR file with this snippet:
#+begin_src bash :tangle bash/install_deps.sh
  # Get a version of the PlantUML jar file.
  install_pkg -x dot graphviz  # for some diagrams
  install_pkg -x wget wget
  URL='http://sourceforge.net/projects/plantuml/files/plantuml.jar/download'
  DIR="${HOME}/Apps"
  if [[ ! -e "${DIR}/plantuml.jar" ]]; then
      [[ -d "${DIR}" ]] || mkdir -p "${DIR}"
      (cd "${DIR}" && wget -O plantuml.jar "${URL}")
      ls -l "${DIR}/plantuml.jar"
  fi
#+end_src

#+RESULTS:

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :ensure t
    :config
    (setq plantuml-jar-path "~/Apps/plantuml.jar")
    (setq org-plantuml-jar-path "~/Apps/plantuml.jar")
    ;; Let us edit PlantUML snippets in plantuml-mode within orgmode
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    ;; make it load this language (for export ?)
    (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t)))
    ;; and re-display images after update
    (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
    ;; Enable plantuml-mode for PlantUML files
    (add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode)))
#+end_src

*** yankpad
Check out the [[https://kungsgeten.github.io/yankpad.html][blog post]] (and the [[https://kungsgeten.github.io/yankpad13.html][follow-up]]) and the [[https://github.com/Kungsgeten/yankpad][package docs]].
#+begin_src emacs-lisp
  (use-package yankpad
    :ensure t
    :defer
    :init
    (setq yankpad-file (org-relative "Templates/yankpad.org"))
    :config
    (bind-key "C-p y m" 'yankpad-map)
    (bind-key "C-p y e" 'yankpad-expand))
#+end_src

* One-time Initial Setup
I have my config in directory =~/Emacs= which is where I clone this repository. The config setup is maintained purely in the =~/Emacs/emacs_setup.org= file.

To bootstrap the process on a new machine, all you need is to run

#+begin_src bash :tangle no
  cd <dir-where-you-expanded-the-git-repository>
  bash ./onetime_setup.sh
#+end_src

In your =~/.emacs= file, all you need to add is

#+NAME: emacs_bootstrap
#+BEGIN_SRC emacs-lisp :tangle lisp/dot_emacs.el
  ;; Setup your Org directory
  (setq org-directory "~/OrgFiles")

  (load-file "~/.emacs.d/init.el")
#+end_src

*** Script to bootstrap the whole thing on a new system
#+begin_src bash :noweb yes :tangle onetime_setup.sh :shebang "#!/bin/bash"
  # Make git ignore the tangled & updated emacs_setup.el
  GIT_ROOT=$(dirname $0)

  # Ensure modules are loaded.
  (cd ${GIT_ROOT} && git submodule init && git submodule update)

  source ${GIT_ROOT}/bash/install.sh

  if [[ -z "$(which git)" ]]; then
      echo "You might need 'git' for this to work ! (how did you get here?)"
      exit 1
  fi
  if  [[ -z "$(which emacs)" ]]; then
      echo "You might need 'emacs' for this to be useful ! Installing..."
      install_pkg -x emacs emacs
  fi

  # Maybe this is a new install, .emacs does not exist
  for file in ~/.emacs ~/.emacs.d/custom.el; do
      test -e ${file} || mkdir -p $(dirname ${file}) && touch ${file}
  done

  # Initial tangle of files, saying no to vterm compilation
  echo "Initial tangling..."
  (cd ${GIT_ROOT} && emacs --batch --load "lisp/first_time_tangle.el")

  # Add the load-file as the first thing in the user's ~/.emacs
  # If not yet added.
  declare lines=$(grep ';; lisp/dot_emacs.el' ~/.emacs | wc -l)
  if (( lines < 1 )); then
      echo "Setup .emacs ..."
      echo ";; lisp/dot_emacs.el" > ~/.emacs.new
      cat "${GIT_ROOT}/lisp/dot_emacs.el" >> ~/.emacs.new
      cat ~/.emacs >> ~/.emacs.new
      mv ~/.emacs.new ~/.emacs
      echo "Added loading the config in your ~/.emacs"
  else
      echo "Config in your ~/.emacs already set up!"
  fi

  # Install system dependencies from the tangled script
  echo "Checking dependencies"
  bash ${GIT_ROOT}/bash/install_deps.sh

  # Load the init, let it install whatever is missing.
  echo "Get Emacs to load fist time..."
  emacs --batch --load "~/.emacs"
#+end_src

This script is then used to install the needed packages on the system.

#+begin_src bash :noweb yes :tangle bash/install_deps.sh :shebang "#!/bin/bash"
  set -e

  # Trick to make it work on Termux
  #which "ls" || pkg install debianutils

  # This is a bit of heuristics to find out what the install system is
  # They are attempted in this order, put the least likely first.
  declare -a PKG_MGRS=("pkg" "brew" "apt-get")

  PKG_PREFIX_apt_get="sudo"
  PKG_POSTFIX_apt_get="-y"

  for pkg in "${PKG_MGRS[@]}"; do
      if [[ -x "$(which ${pkg})" ]]; then
          INSTALLER="${pkg}"
          break
      fi
  done
  if [[ -z "${INSTALLER}" ]]; then
      echo "Did not find a suitable installer (tried ${PKG_MGRS[@]})"
      exit 1
  fi

  # This is the function to call to install anything. It can optionally
  # check for a binary and avoid installing if it's found.  install_pkg
  # [-x <binary>] <package>
  function install_pkg() {
      if [[ "$1" == "-x" ]]; then
          local binary="$(which $2)"
          if [[ -n "${binary}" && -x "${binary}" ]]; then
              echo "Found $2 (${binary}), nothing to install for $3."
              return
          fi
          shift 2
      fi

      local token=$(echo -n ${INSTALLER} | tr -c '0-9a-zA-Z_' '_')
      local prefix_var="PKG_PREFIX_${token}"
      local postfix_var="PKG_POSTFIX_${token}"

      echo "Trying: ${INSTALLER} install $*"
      ${!prefix_var} $(which ${INSTALLER}) ${!postfix_var} install "$@"
  }
#+end_src

*** TODO detect the system better
:LOGBOOK:
- State "TODO"       from              [2021-02-03 Wed 16:57]
:END:
currently it does not a good job of figuring out the diff between OSX, Linux, Termux (Android) and Windows.

** Recompile all packages
This will force-recompile everything in =~/.emacs.d/elpa/...= Just run =M-:= and then enter this:
#+begin_src emacs-lisp :tangle no
(byte-recompile-directory package-user-dir nil 'force)
#+end_src
or simply =C-x C-e= at the end of that line.

* The End
#+begin_src emacs-lisp
(load-file custom-file)
;; ============ end of emacs_setup.org ====================
;;  (profiler-stop)
;;  (profiler-report)
#+end_src
